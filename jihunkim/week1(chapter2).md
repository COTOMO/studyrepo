## 자바스크립트 기본

### 2.1 Hello, world!

<strong> 2.1.1 html 파일을 통한 자바스크립트를 실행하는 방법</strong>

```<script>```태그를 이용!!!

여러가지 방법이 존재하지만 외부 자바스크립트 파일을 import할 시에는 html파일에서 ```head```태그에 ```<script src="path/to/외부스크립트파일이름.js"></script>``` 와 같이 입력하는 방법을 많이 사용

> ❗```<script>``` 태그는 HTML 문서 상 어디에 위치해야 할까?
>
> ```<head>``` 태그 또는 ```<body>``` 태그 어느 위치던 크게 상관없지만, 웹 검색이나 서적마다 작성 위치가 다르고 관련해서 전혀 언급이 없음
>
> **브라우저 동작 방식**: [참고 링크](https://blog.martinwork.co.kr/javascript/2018/10/13/how-js-works-in-browser.html)
>
> 1. HTML을 읽기 시작
>
> 2. HTML을 파싱
>
> 3. DOM트리를 생성
>
> 4. Render트리(DOM tree + CSS에 CSSOM 트리 결합)가 생성
>
> 5. 화면에 표시
>
>    ![img](https://media.vlpt.us/post-images/takeknowledge/aea046b0-2404-11ea-addc-59a0f147306b/image.png)
>
>    HTML을 파싱한 다음 DOM 트리를 생성하는데, 브라우저는 HTML 태그들을 읽어나가는 도중 `<script>` 태그를 만나면 파싱을 중단하고 javascript 파일을 로드 후 javascript 코드를 파싱하기 시작하고, 해당 작업이 완료되면 그 후에 HTML 파싱이 계속된다.
>
> 
>
>    이로인해 HTML태그들 사이에 script 태그가 위치하면 두가지 문제가 발생하는데,
>
>    1. HTML을 읽는 과정에 스크립트를 만나면 중단 시점이 생기고 그만큼 화면에 표시되는 것이 지연
>
>    2. DOM 트리가 생성되기전에 자바스크립트가 생성되지도 않은 DOM의 조작을 시도시에 문제가 발생
>
>          **그렇기 때문에 위와 같은 상황을 막기 위해 script 태그는 body 태그 최하단 에 위치하는 게 가장 좋다**

### 2.2 코드 구조

**Expression(표현식)**: 값을 만들어내는 간단한 코드

```j
123
11 + 12 + 13 * 14
'Hello'
```

**Statement(문)**: 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미하는데, 쉽게 말해 하나 이상의 표현식이 모이면 Statement(문)이 되며, 하나의 Expression(표현식)도 문장의 종결을 의미하는 세미콜론 또는 줄바꿈을 넣으면 Statement(문)라고 부른다.

**Program(프로그램)**: Statement(문)이 모여 Program(프로그램)이 된다.

> ❗ Javascript에서 Statement(문)의 종결을 의미하기 위해 끝에 semicolon(세미콜론)을 넣는다. 또한 줄 바꿈이 있으면 이를 ‘암시적’ 세미콜론으로 해석합니다. 이런 동작 방식을 [세미콜론 자동 삽입(automatic semicolon insertion)](https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion)이라 부르며 대부분의 경우에는 줄 바꿈은 semicolon(세미콜론)을 의미하지만, **항상** 을 의미하진 않는다.
>
> 그렇기 때문에, 줄 바꿈으로 Statement(문)를 나눴더라도, Statement(문) 사이엔 semicolon(세미콜론)을 넣는 것이 좋으며 자바스크립트 커뮤니티에서도 이를 규칙으로 정해 권장하고 있다.
>
> **세미콜론은 *생략할 수 있다.* 하지만 세미콜론을 사용하는 것이 여러모로 안전하므로 이를 기억하고 따르도록 하자!!**

### 2.3 엄격 모드

ECMAScript5(ES5)부터 만들어진 기능이며, 새로운 기능들을 ES5 이전 하위 호환성을 위해 ```use strict``` 키워드를 통해 활성화 시에만 사용가능하도록 하게 만든 Mode가 바로 Strict Mode(엄격 모드)다. 특히 JavaScript 코드에 더욱 엄격한 오류 검사를 적용하여 기존에 무시되던 오류를 발생시킬 가능성이 높거나 Javascript 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.

> ```"use strict"```는 반드시 최상단에 위치시켜야 한다.**
>
> `"use strict"`**를 취소할 방법은 없기 때문에 적용 시 유의해야 한다.**
>
> ❗ ```"use strict"```를 반드시 사용해야 할까?
>
> > 모던 자바스크립트는 '클래스’와 '모듈’이라 불리는 진일보한 구조를 제공하는데, 이 둘을 사용하면 `"use strict"`가 자동으로 적용된다. 따라서 이 둘을 사용하고 있다면 스크립트에 `"use strict"`를 붙일 필요가 없다. 
> >
> > **결론: 코드를 클래스와 모듈을 사용해 구성한다면 `"use strict"`를 생략해도 된다.** 

> ❗ 흔하진 않지만, 오래된 브라우저에서 'use strict'를 사용할 수 없다면, 아래 코드와 같이 즉시실행함수를 통해 엄격모드를 사용 가능한다.
>
> ```javascript
> (function() {
> 'use strict';
> 
> // ...테스트하려는 코드...
> })()
> ```

### 2.4 변수와 상수

> ❗**선언**: 상수나 변수를 만드는 과정이며, **변수와 상수는 같은 이름으로 두 번이상 선언하면 에러가 발생한다.**
>
> ❗변수와 상수 이름 규칙
>
> > 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있다.
> >
> > 첫 글자는 숫자가 될 수 없다.
> >
> > 대·소문자 구별
> >
> > reserved name(예약어)을 사용할 수 없다.

> **Variable(변수)**: 변할 수 있는 수(위가 뚫려 있어서 값을 꺼내서 버리고 다시 넣을 수 있는 상자)또는 저장소
>
> ```let``` 키워드를 통해 선언(`var` – 오래된 변수 선언 키워드이며, 현재는 잘 사용하지 않는다, 변수를 중복해서 선언할 수 있다는 위험성, 변수가 속하는 범위가 애매한다는 이유로 ```let``` 키워드가 등장하면서 대체 됨)
>
> ``` javascript
> let message;
> 
> message = 'Hello!';
> 
> message = 'World!'; // 값이 변경
> 
> alert(message);
> ```

> **Constant**(상수): 항상 같은 수(한번 값을 넣으면 꺼낼 수 없는 모든 면이 막힌 단단한 상자)또는 저장소
>
> ```const``` 키워드를 통해 선언
>
> ``` javascript
> const myBirthday = '18.04.1982';
> 
> myBirthday = '01.01.2001'; // error, can't reassign the constant!
> ```
>
> > ❗상수관련 에러 종류
> >
> > > **Identifier has already declared **
> > >
> > > => 같은 이름으로 상수를 한번 더 선언시 해당 오류 발생
> > >
> > > ``` javascript
> > > > const name = "name이란 변수 선언"
> > >   undefined
> > > > const name = "name이란 변수를 한번 더 선언!"
> > >   Uncaught SyntaxError: Identifier 'name' has already been declared
> > > ```
> > >
> > > **Missing initializer in const declaration**
> > >
> > > => 상수는 한 번만 선언할 수 있으므로 선언할 때 반드시 값을 함께 지정해줘야 함, 만약 상수를 선언할 때 값을 지정해주지 않는다면 해당 오류가 발생
> > >
> > > ``` javascript
> > > > const pi
> > >   Uncaught SyntaxError: Missing initializer in const declaration
> > > ```
> > >
> > > **Assignment to constant variable** 
> > >
> > > => 한 번 선언된 상수의 자료는 변경할 수 없다. 만약 값을 변경하면 해당 오류가 발생
> > >
> > > ``` javascript
> > > > const name = "name이라는 이름의 상수를 선언"
> > >   undefined
> > > > name = "이 값을 변경하면?"
> > >   TypeError: Assignment to constant variable
> > > ```

#### 2.5 자료형

**Data type(자료형)**: 프로그래밍에서 프로그램이 처리할 수 있는 모든 것을 Data(자료)라고 부르며, 자료 형태에 따라 나눠 놓은 것을 Data Type(자료형)이라 한다.

> Javascript에서 제공하는 Data type(자료형)은 `number, string, boolean, null, undefined, obeject, symbol`이 있으며, 가장 기본적이면서도 많이 사용하는 자료형은 `number, string, boolean` 이다.

**number data type(숫자 자료형)**: Javascript는 소수점이 있는 숫자와 없는 숫자를 모두 같은 자료형으로 인식함.

> ```js
> > 123
> 123
> > 123.123 // 소숫점이 있던 없든 모두 같은 숫자 자료형
> 123.123
> ```

**boolean data type(불 자료형)**: `true` 와 `false` 두 값만 가지는 자료형이며, 두 대상을 비교할 수 있는 `비교 연산자`를 사용해도 해당 자료형을 만들 수 있다.

> | **비교 연산자** | **설 명**                                     |
> | --------------- | --------------------------------------------- |
> | **`==, ===`**   | 양쪽이 같다, 양쪽이 같다(자료형도 일치)       |
> | **`!=, !==`**   | 양쪽이 다르다, 양쪽이 다르다(자료형도 불일치) |
> | **`>`**         | 왼쪽이 더 크다                                |
> | **`<`**         | 오른쪽이 더 크다                              |
> | **`>=`**        | 왼쪽이 더 크거나 같다                         |
> | **`<=`**        | 오른쪽이 더 크거나 같다                       |
>
> ```js
> > 12 > 123
> false
> > 10 === 10
> true
> > 10 === '10'
> false
> ```

**null data type(널 자료형)**: ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용하는 자료형

> ```js
> > let age = null
> ```

**undefined data type(Undefined 자료형)**: '값이 할당되지 않은 상태’를 나타낼 때 사용하는 자료형

> ```js
> > let age // 변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 undefined가 자동으로 할당
> undefined
> > let name = 'Jihun Kim'
> > name = undefined
> undefined
> ```

**Object and symbol(객체와 심볼 자료형)**: `객체(object)`형은 특수한 자료형이며, 객체형을 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부른다. `심볼(symbol)`형은 객체의 고유한 식별자(unique identifier)를 만들 때 사용함

> ❗typeof 연산자
>
> `typeof` 연산자는 두 가지 형태의 문법을 지원한다.
>
> > 연산자 형태: `typeof x`
> >
> > 함수 형태: `typeof(x)`
> >
> > ```js
> > typeof undefined // "undefined"
> > 
> > typeof 0 // "number"
> > 
> > typeof 10n // "bigint"
> > 
> > typeof true // "boolean"
> > 
> > typeof "foo" // "string"
> > 
> > typeof Symbol("id") // "symbol"
> > 
> > typeof Math // "object" 
> > 
> > typeof null // "object" (Javascript 설계 실수이며 현재는 이전 개발된 프로그램과의 호환성등으로 수정하지 않음)
> > 
> > typeof alert // "function"
> > ```

> ❗template literal(템플릿 리터럴) or template strings(템플릿 문자열)
>
> 과거(ES6 이전) Javascript는 문자열 내부에 표현식을 삽입할 때 다음과 같은 문자열 연결 연산자(+)를 사용해야 했음
>
> ```js
> > console.log('표현식 123 + 456의 값은 ' + (123 + 456) + '입니다!')
> 표현식 123 + 456의 값은 579입니다!
> ```
>
> 이런 작성법에 문제가 있는 건 아니지만, 표현식을 많이 결합할수록 코드가 복잡해진다. 그렇기 때문에 Javascript에서는 `template literal(템플릿 리터럴)`이라는 기능이 추가되어 코드를 간단하게 작성할 수 있다.
>
> template literal(템플릿 리터럴)은 backtick(`)기호로 감싸 만들며, 문자열 내부에 ${...}기호를 사용하여 표현식을 넣으면 표현식이 문자열 안에서 계산된다.
>
> ```js
> > console.log(`표현식 123 + 456의 값은 ${123 + 456}입니다!`)
> 표현식 123 + 456의 값은 579입니다!
> ```

#### 2.6 alert, prompt, confirm을 이용한 상호작용

> 브라우저 환경에서 사용되는 최소한의 사용자 인터페이스 기능, 세 함수들은 모두 모달 창이라는 것을 띄워주는데, 모달 창이 떠 있는 동안은 스크립트의 실행이 일시 중단돠며 사용자가 창을 닫기 전까진 나머지 페이지와 상호 작용이 불가능하다.

**alert**: 이 함수가 실행되면 사용자가 ‘확인(OK)’ 버튼을 누를 때까지 메시지를 보여주는 창이 계속 떠있게 되며, 메시지가 있는 작은 창은 *모달 창(modal window)* 이라고 부른다. '모달’이란 단어엔 페이지의 나머지 부분과 상호 작용이 불가능하다는 의미가 내포되어 있으며 사용자는 확인 버튼을 누르기 전까지, 모달 창 바깥에 있는 버튼을 누른다든가 하는 행동을 할 수 없다.

> modal window(모달 창)
>
> > 모달 창의 위치는 브라우저가 결정하는데, 대개 브라우저 중앙에 위치한다.
> >
> > 모달 창의 모양은 브라우저마다 다릅니다. 개발자는 창의 모양을 수정할 수 없다.

**prompt**: 이 함수가 실행되면 텍스트 메시지와 입력 필드(input field), 확인(OK) 및 취소(Cancel) 버튼이 있는 모달 창을 띄워준다.

> 브라우저에서 제공하는 `prompt` 함수는 두 개의 인수를 받습니다.
>
> ```js
> result = prompt(title, [default])
> ```
>
> **title**: 사용자에게 보여줄 문자열 **default**: 입력 필드의 초깃값(선택값)
>
> `prompt` 함수는 사용자가 입력 필드에 기재한 문자열을 반환하며, 사용자가 입력을 취소한 경우는 `null`이 반환된다.

> ❗**인수를 감싸는 대괄호 `[...]`의 의미**
>
> `default`를 감싸는 대괄호는 이 매개변수가 필수가 아닌 선택값이라는 것을 의미한다.

**confirm**: 이 함수는 매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여주며, 사용자가 확인버튼를 누르면 `true`, 그 외의 경우는 `false`를 반환한다.

> ❗세 사용자 인터페이스 함수의 출력 결과 정리
>
> **alert**: 확인 버튼을 누를 때까지 메세지를 출력해준다.
>
> **confirm**: 사용자가 [확인]을 선택하면 true를 [취소]를 선택하면 false 값을 반환한다.
>
> **prompt**: 사용자가 첫번째 인수에 값을 입력할 경우 해당 값을 반환하며, [취소]를 선택하면 `null`을 반환한다.

#### 2.7 형 변환(type conversion)

> **❗우선, 자바스크립트 튜토리얼에서는 \**형 변환\**을 type conversion이란 명칭을 사용 했지만, 웹 및 타 문서에서는 type casting이란 용어로도 사용하고 있어 관련 용어가 잘못 혼용되고 있는 게 아닐까란 생각이 들어 정확한 의미를 아래 키워드를 통해 찾아보았다.**
>
> > **`What is the difference between type conversion and type casting [in javascript]?`**
> >
> > **1. Type Casting:** 타입 캐스팅의 경우 프로그램 설계 중에 프로그래머가 해당 언어의 캐스팅 연산자를 사용하여 기존 데이터 유형을 다른 데이터 유형으로 의도적으로 변환하는 작업
> >
> > **2.Type conversion**: 타입 컨버젼의 경우 데이터 타입이 컴파일러 또는 인터프리터 등을 통해 컴파일러타임, 런타임을 통해 자동으로 다른 데이터 타입으로 변환되는 작업. 그렇기에 대상 데이터 타입은 변경되는 타입보다 작을 수 없으므로 확장 변환(widening conversion)이라고도 한다. 그리고 가장 중요한 점은 서로 호환이 가능한 데이터 타입에만 적용할 수 있다.

##### 문자형으로 변환

> 문자형으로의 형 변환은 문자형의 값이 필요할 때 일어나는데, `alert`메서드는 매개변수로 문자형을 받기 때문에, `alert(value)`에서 value는 문자형이어야 한다. 만약, 다른 형의 값을 전달받으면 이 값은 문자형으로 자동 변환된다. 그리고, `String(value)` 함수를 호출해 전달받은 값을 문자열로 변환 할 수도 있다.

```js
let value = true;
alert(typeof value); // boolean

value = String(value); // 변수 value엔 문자열 "true"가 저장된다.
alert(typeof value); // string
```

**`false`는 문자열 `"false"`로, `null`은 문자열 `"null"`로 변환되는 것과 같이, 문자형으로의 변환은 대부분 예측 가능한 방식으로 일어난다.**

##### 숫자형으로 변환

```js
숫자으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.
alert( "6" / "2" ); // 3, 문자열이 숫자형으로 자동변환된 후 연산이 수행된다.

Number(value) 함수를 사용하면 주어진 값(value)을 숫자형으로 명시해서 변환할 수 있다.
let str = "123";
alert(typeof str); // string

let num = Number(str); // 문자열 "123"이 숫자 123으로 변환된다.

alert(typeof num); // number


숫자형 값를 사용해 무언가를 하려고 하는데 그 값을 문자 기반 폼(form)을 통해 입력받는 경우엔, 이런 명시적 형 변환이 필수인데 숫자 이외의 글자가 들어가 있는 문자열을 숫자형으로 변환하려고 하면, 그 결과는 NaN이 된다.

let age = Number("임의의 문자열 123");

alert(age); // NaN, 형 변환이 실패된다.
```

아래는, 숫자형으로 변환 시에 적용되는 규칙을 정리해보았다.

| 전달받은 값      | 형 변환 후                                                   |
| ---------------- | ------------------------------------------------------------ |
| `undefined`      | `NaN`                                                        |
| `null`           | `0`                                                          |
| `true and false` | `1` 과 `0`                                                   |
| `string`         | 문자열의 처음과 끝 공백이 제거되며, 공백 제거 후 남아있는 문자열이 없다면 `0`, 그렇지 않다면 문자열에서 숫자를 읽는다. 또, 변환에 실패하면 `NaN`이 된다. |

```js
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN ("z"를 숫자로 변환하는 데 실패함)
alert( Number(true) );        // 1
alert( Number(false) );       // 0

`null과 undefined은 숫자형으로 변환 시 결과가 다르다는 점에 유의하시기 바랍니다. null은 0이 되고 undefined는 NaN이 된다.`
```

##### 불린형으로 변환

`Boolean(value)`를 호출하면 명시적으로 불리언으로의 형 변환을 수행할 수 있으며, 불린형으로 변환 시 적용되는 규칙은 아래와 같다.

> 숫자 `0`, 빈 문자열, `null`, `undefined`, `NaN`과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 `false`가 되며, 그 외의 값은 `true`로 변환된다.

```js
alert( Boolean(1) ); // 숫자 1(true)
alert( Boolean(0) ); // 숫자 0(false)

alert( Boolean("hello") ); // 문자열(true)
alert( Boolean("") ); // 빈 문자열(false)

`주의: 문자열 "0"은 true이다!!`
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // 공백이 있는 문자열도 비어있지 않은 문자열이기 때문에 true로 변환된다.
```

##### 정리

문자, 숫자, 논리형으로의 형 변환은 자주 일어나는 형 변환이다.

**`문자형으로 변환`** 은 무언가를 출력할 때 주로 일어난다. `String(value)`을 사용하면 문자형으로 명시적 변환이 가능하다. 원시 자료형을 문자형으로 변환할 땐, 대부분 그 결과를 예상할 수 있을 정도로 명시적인 방식으로 일어난다.

**`숫자형으로 변환`**은 수학 관련 연산시 주로 일어난다. `Number(value)`로도 형 변환을 할 수 있다.

**숫자형으로의 변환은 아래 규칙을 따른다.**

| 전달받은 값    | 형 변환 후                                                   |
| -------------- | ------------------------------------------------------------ |
| `undefined`    | `NaN`                                                        |
| `null`         | `0`                                                          |
| `true / false` | `1 / 0`                                                      |
| `string`       | 전달받은 문자열을 “그대로” 읽되, 처음과 끝의 공백을 무시한다. 문자열이 비어있다면 `0`이 되고, 오류 발생 시 `NaN`이 된다. |

**`불린형으로 변환`** 은 논리 연산 시 발생한다. `Boolean(value)`으로도 변환할 수 있다.

**불린형으로의 형 변환은 다음 규칙을 따른다.**

| 전달받은 값                           | 형 변환 후 |
| ------------------------------------- | ---------- |
| `0`, `null`, `undefined`, `NaN`, `""` | `false`    |
| 그 외의 값                            | `true`     |

**형 변환 시 적용되는 규칙 대부분은 이해하고 기억하기 쉬운 편에 속한다. 다만 아래는 예외적인 경우이기 때문에 실수를 방지하기 위해 따로 기억해 두자.**

1.숫자형으로 변환 시 `undefined`는 `0`이 아니라 `NaN`이 된다.

2.문자열 `"0"`과 `" "`같은 공백은 불린형으로 변환 시 `true`가 된다.

## 2.8 기본 연산자와 수학

**operand**(피연산자): 연산자가 연산을 수행하는 대상, 예를 들어 `5 * 2`에는 왼쪽 피연산자 `5`와 오른쪽 피연산자 `2`, 총 두 개의 피연산자가 있다. '피연산자’는 'argument(인수)'라는 용어로 불리기도 한다.

**unary**(단항)연산자: 피연산자를 하나만 받는 연산자, 피연산자의 부호를 뒤집는 단항 마이너스 연산자 `-`는 단항 연산자의 대표적인 예이다.

```js
let x = 1;

x = -x;
alert( x ); // -1, 단항 마이너스 연산자는 부호를 뒤집는다.
```

**binary**(이항)연산자: 두 개의 피연산자를 받는 연산자

```js
let x = 1, y = 3;
alert( y - x ); // 2, 이항 마이너스 연산자는 뺄셈을 해준다.
```

**위와 같이 부호를 반전해주는 단항 마이너스 연산자와 뺄셈에 쓰이는 이항 마이너스 연산자(뺄셈 연산자)는 기호는 같지만 수행하는 연산이 다르다. 두 연산을 구분하는 기준은 피연산자의 갯수이다.**

> **수학**
>
> 자바스크립트에서 지원하는 수학 연산자는 다음과 같다.
>
> > **덧셈 연산자 `+`, 뺄셈 연산자 `-`, 곱셈 연산자 `*`, 나눗셈 연산자 `/`, 나머지 연산자 `%`, 거듭제곱 연산자** 

**remainder operator**(나머지 연산자): `%` 기호로 나타내지만, 비율을 나타내는 퍼센트와 관련이 없다.

```js
나머지 연산자를 사용한 표현식 a % b는 a를 b로 나눈 후 그 remainder(나머지)를 정수로 반환해 준다.

alert( 5 % 2 ); // 5를 2로 나눈 후의 나머지인 1을 출력
alert( 8 % 3 ); // 8을 3으로 나눈 후의 나머지인 2를 출력
```

**exponentiation operator**(거듭제곱 연산자): `**` 기호를 사용하며, `a ** b`를 평가하면 `a`를 `b`번 곱한 값이 반환된다.

```js
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)

거듭제곱 연산자는 정수가 아닌 숫자에 대해서도 동작한다. 1/2을 사용하면 제곱근을 구할 수 있죠.

alert( 4 ** (1/2) ); // 2 (1/2 거듭제곱은 제곱근)
alert( 8 ** (1/3) ); // 2 (1/3 거듭제곱은 세제곱근)
```

**이상 연산자 '+'와 문자열 연결**

덧셈 연산자 `+`는 대개 숫자를 더한 결과를 반환하는데, 이항 연산자 `+`의 피연산자로 `문자열`이 전달되면 덧셈 연산자는 `덧셈이 아닌 문자열을 병합(연결)한다.`

**따라서 이항 연산자 `+`를 사용할 때는 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다는 점에 반드시 주의해야 한다!**

```js
let s = "my" + "string";
alert(s); // mystring

첫 번째 피연산자가 문자열인지, 두 번째 피연산자가 문자열인지는 중요하지 않습니다. 피연산자 중 어느 하나가 문자열이면 다른 하나도 문자열로 변환된다.
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"

alert(2 + 2 + '1' ); // '221'이 아니라 '41'이 출력된다.
```

연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문에 이런 결과가 나왔다. 두 개의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 숫자와 문자열과의 병합이 일어난다. 이처럼 이항 덧셈 연산자 `+`는 문자열 연결과 변환이라는 특별한 기능을 제공한다. **`다른 산술 연산자가 오직 숫자형의 피연산자`만 다루고, `피연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로 바꾸는 것`과는 대조적이다.**

아래는 뺄셈 `-`과 나눗셈 `/` 연산자가 어떻게 문자형 피연산자를 다루는지를 보여준다.

```js
alert( 6 - '2' ); // 4, '2'를 숫자로 바꾼 후 연산이 진행된다.
alert( '6' / '2' ); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행된다.
```

**단항 연산자 +와 숫자형으로의 변환**

숫자에 단항 덧셈 연산자를 붙이면 이 연산자는 아무런 동작도 하지 않지만 피연산자가 `숫자가 아닌 경우엔 숫자형으로의 변환이 일어납니디.`

```js
// 숫자에는 아무런 영향을 미치지 않는다.
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 숫자형이 아닌 피연산자는 숫자형으로 변화한다.
alert( +true ); // 1
alert( +"" );   // 0
```

**단항 덧셈 연산자는 위 예제와 같이 짧은 문법으로도 `Number(...)`와 동일한 일을 할 수 있게 해준다.**

#### 연산자 우선순위

| 순위 | 연산자 이름 | 기호 |
| ---- | ----------- | ---- |
| …    | …           | …    |
| 17   | 단항 덧셈   | `+`  |
| 17   | 단항 부정   | `-`  |
| 16   | 지수        | `**` |
| 15   | 곱셈        | `*`  |
| 15   | 나눗셈      | `/`  |
| 13   | 덧셈        | `+`  |
| 13   | 뺄셈        | `-`  |
| …    | …           | …    |
| 3    | 할당        | `=`  |
| …    | …           | …    |

- **증가(increment) 연산자** `++`는 변수를 1 증가

  ```js
  let counter = 2;
  counter++;      // counter = counter + 1과 동일하게 동작하지만 식은 더 짧다.
  alert( counter ); // 3
  ```

- **감소(decrement) 연산자** `--`는 변수를 1 감소

  ```js
  let counter = 2;
  counter--;      // counter = counter - 1과 동일하게 동작하지만 식은 더 짧다.
  alert( counter ); // 1
  ```

**중요:**

증가/감소 연산자는 `변수에만` 쓸 수 있습니다. `5++`와 같이 값에 사용하려고 하면 에러가 발생한다.

`++`와`--` 연산자는 변수 앞이나 뒤에 올 수 있다.

- `counter++`와 같이 피연산자 뒤에 올 때는, 'postfix form(후위형)'이라고 부른다.
- `++counter`와 같이 피연산자 앞에 올 때는, 'prefix form(전위형)'이라고 부른다.

후위형과 전위형은 피연산자인 `counter`를 `1`만큼 증가시켜 준다는 점에서 동일한 일을 한다.

두 형의 차이는 `++/--`의 반환 값을 사용할 때 드러난다.

모든 연산자는 값을 반환한다. 증가/감소 연산자도 마찬가지인데, 전위형은 증가/감소 후의 새로운 값을 반환하는 반면, 후위형은 증가/감소 전의 기존 값을 반환한다.

```js
let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
```

`(*)`로 표시한 줄의 *전위형* `++counter`는 `counter`를 증가시키고 새로운 값 `2`를 반환한다. 따라서 `alert`는 `2`를 표시된다.

```js
let counter = 1;
let a = counter++; // (*) ++counter를 counter++로 바꿈

alert(a); // 1
```

`(*)`로 표시한 줄의 *후위형* `counter++`는 `counter`를 증가시키긴 하지만, 증가 전의 *기존* 값을 반환한다. 따라서 `alert`는 `1`을 표시한다.

- **반환 값을 사용하지 않는 경우라면, 전위형과 후위형엔 차이가 없다.**

  ```js
  let counter = 0;
  counter++;
  ++counter;
  alert( counter ); // 2, 위 두 라인은 동일한 연산을 수행합니다.
  ```

- > 값을 증가시키고 난 후, 증가한 값을 바로 사용하려면 전위형 증가 연산자를 사용하면 된다.

  ```js
  let counter = 0;
  alert( ++counter ); // 1
  ```

- > 값을 증가시키지만, 증가 전의 기존값을 사용하려면 후위형 증가 연산자를 사용하면 된다.

  ```js
  let counter = 0;
  alert( counter++ ); // 0
  ```

**다른 연산자 사이의 증가/감소 연산자**

`++/--` 연산자를 표현식 중간에 사용하는 것도 가능합니다. 이때, 증가/감소 연산자의 우선순위는 다른 대부분의 산술 연산자보다 높기 때문에, 평가가 먼저 이뤄진다.

```js
let counter = 1;
alert( 2 * ++counter ); // 4
let counter = 1;
alert( 2 * counter++ ); // counter++는 '기존'값을 반환하기 때문에 2가 출력된다.
```

**이렇게 코드를 작성하는 게 기술적으로 문제가 있는 것은 아니지만, 한 줄에서 여러 가지 일을 동시에 하고 있기 때문에 코드의 가독성이 떨어진다.**

코드를 읽을 때 눈을 ‘수직으로’ 빠르게 움직이다 보면 `counter++`와 같은 것을 놓치기 쉬워 변수가 증가했다는 것을 놓칠 수 있죠.

'코드 한 줄엔, 특정 동작 하나’에 관련된 내용만 작성하는 게 좋다.

```js
let counter = 1;
alert( 2 * counter );
counter++;
```

## [비트 연산자](https://ko.javascript.info/operators#ref-157)

bitwise operator(비트 연산자): 인수를 32비트 정수로 변환하여 이진 연산을 수행하는 연산자

> - 비트 AND ( `&` )
> - 비트 OR ( `|` )
> - 비트 XOR ( `^` )
> - 비트 NOT ( `~` )
> - 왼쪽 시프트(LEFT SHIFT) ( `<<` )
> - 오른쪽 시프트(RIGHT SHIFT) ( `>>` )
> - 부호 없는 오른쪽 시프트(ZERO-FILL RIGHT SHIFT) ( `>>>` )

비트 연산자는 저수준(2진 표현)에서 숫자를 다뤄야 할 때 쓰이므로 흔하게 쓰이진 않는다. 웹 개발 시엔 이런 일이 자주 일어나지 않기 때문에 비트 연산자를 만날 일은 거의 없다. 하지만, 암호를 다뤄야 할 땐 비트 연산자가 유용하기 때문에 때가 되면 MDN의 [비트 연산자](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) 문서를 보시는 걸 추천한다.

## 쉼표 연산자

comma operator(쉼표 연산자): `,`는 좀처럼 보기 힘들고, 특이한 연산자 중 하나다. 코드를 짧게 쓰려는 의도로 가끔 사용되는데 이런 코드를 만났을 때 어떤 연산 결과가 도출되는지 알아야 한다.

쉼표 연산자 `,`는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다. 이때 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환되는 점에 유의해야한다.

```js
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (3 + 4의 결과)
```

위 예시에서 첫 번째 표현식 `1 + 2`은 평가가 되지만 그 결과는 버려진다. `3 + 4`만 평가되어 `a`에 할당된다.

**쉼표의 우선순위는 매우 낮다.**

그렇기에, 쉼표 연산자의 연산자 우선순위는 매우 낮습니다. 할당 연산자 `=` 보다 더 낮다. 따라서 위 예시에선 괄호가 중요한 역할을 한다.

괄호가 없으면 `a = 1 + 2, 3 + 4`에서 `+`가 먼저 수행되어 `a = 3, 7`이 된다. 할당 연산자 `=`는 쉼표 연산자보다 우선순위가 높기 때문에 `a = 3`이 먼저 실행되고, 나머지(`7`)는 무시된다. `(a = 1 + 2), 3 + 4`를 연산한 것처럼 결과가 발생한다.

> **❗**이렇게 마지막 표현식을 제외한 모든 것을 버리는 연산자는 어디서 사용되는 걸까?
>
> 여러 동작을 하나의 줄에서 처리하려는 복잡한 구조에서 이를 사용한다.
>
> ```js
> // 한 줄에서 세 개의 연산이 수행됨
> for (a = 1, b = 3, c = a * b; a < 10; a++) {
>  ...
> }
> ```

**쉼표 연산자를 사용한 트릭은 여러 자바스크립트 프레임워크에서 볼 수 있다. 이 연산자의 사용 빈도가 높지 않지만, 언급하고 넘어가는 이유다. 쉼표 연산자는 코드 가독성에 도움이 되지 않기 때문에, 곰곰이 생각해 본 후, 진짜 필요한 경우에만 사용하자.**

> **quiz**
>
> 아래 표현식들의 결과를 예측해보라.
>
> ```js
> "" + 1 + 0
> "" - 1 + 0
> true + false
> 6 / "3"
> "2" * "3"
> 4 + 5 + "px"
> "$" + 4 + 5
> "4" - 2
> "4px" - 2
> 7 / 0
> "  -9  " + 5
> "  -9  " - 5
> null + 1
> undefined + 1
> " \t \n" - 2
> ```

> 해답
>
> ```js
> "" + 1 + 0 = "10" // (1)
> "" - 1 + 0 = -1 // (2)
> true + false = 1
> 6 / "3" = 2
> "2" * "3" = 6
> 4 + 5 + "px" = "9px"
> "$" + 4 + 5 = "$45"
> "4" - 2 = 2
> "4px" - 2 = NaN
> 7 / 0 = Infinity
> "  -9  " + 5 = "  -9  5" // (3)
> "  -9  " - 5 = -14 // (4)
> null + 1 = 1 // (5)
> undefined + 1 = NaN // (6)
> " \t \n" - 2 = -2 // (7)
> ```
>
> 1. 피 연산자 중 하나가 문자열인 `"" + 1`에서 `1`은 문자형으로 변환된다. 따라서 공백과 문자열 1을 더한, `"" + 1 = "1"`과 같은 효과를 내는데 그다음 연산 `"1" + 0`에도 같은 규칙이 적용된다.
> 2. 뺄셈 연산자 `-`는 기타 수학 연산자처럼 숫자형만을 인수로 받는다. 빈 문자열 `""`는 숫자 `0`으로 변환되기 때문에 결과는 `-1`이 된다.
> 3. 피 연산자 중 하나가 문자열이므로 숫자 5가 문자열로 변환된다.
> 4. 뺄셈 연산자는 인수를 숫자형으로 변화시키므로 `" -9 "`는 숫자 `-9`로 변합니다. 앞, 뒤 공백은 제거 된다.
> 5. 숫자형으로 변환 시 `null`은 `0`이 된다.
> 6. `undefined`는 숫자형으로 변환시 `NaN`이 된다.
> 7. 문자열이 숫자형으로 변할 땐 문자열 앞뒤의 공백이 삭제된다. 뺄셈 연산자 앞의 피연산자는 공백을 만드는 문자 `\t`와 `\n`, 그 사이의 “일반적인” 공백으로 구성된다. 따라서 `" \t \n"`는 숫자형으로 변환 시 길이가 `0`인 문자열로 취급되어 숫자 `0`이 된다.

**❗**숫자형으로 변환 시 `null`은 `0`이 되고, `undefined`는 숫자형으로 변환시 `NaN`이 된다.

> **quiz**
>
> 아래 코드는 사용자에게 숫자 2개를 입력받은 다음 그 합을 보여준다.
>
> 그런데 의도한 대로 예시가 동작하지 않는다. 프롬프트 창에 세팅한 기본값을 수정하지 않은 경우 덧셈의 결과는 `12`가 된다.
>
> 왜 그럴까? 예시가 제대로 동작하도록 코드를 수정해 보자. 결과는 `3`이 되어야 한다.
>
> ```js
> let a = prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
> let b = prompt("덧셈할 두 번째 숫자를 입력해주세요.", 2);
> 
> alert(a + b); // 12
> ```

> 해답
>
> 의도한 대로 덧셈이 되지 않는 이유는 prompt 함수가 사용자 입력을 문자열로 반환하기 때문이다.
>
> 그래서 프롬프트 창에서 입력한 변수들은 각각 문자열인 `"1"`과 `"2"`가 된다.
>
> ```js
> let a = "1"; // prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
> let b = "2"; // prompt("덧셈할 두 번째 숫자를 입력해주세요.", 2);
> 
> alert(a + b); // 12
> ```
>
> 예시가 제대로 동작하게 하려면 덧셈 연산 `+`가 수행되기 전에 문자열을 숫자로 변환해야 한다. 이때 `Number()`를 사용하거나 변수 앞에 `+`를 붙여줄 수 있다.
>
> 아래 코드에선 `prompt` 함수 바로 앞에서 문자열을 숫자로 변환했다.
>
> ```js
> let a = +prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
> let b = +prompt("덧셈할 두 번째 숫자를 입력해주세요.", 2);
> 
> alert(a + b); // 3
> ```
>
> 아래 코드에선 `alert` 함수 안에서 문자열을 숫자로 변환해 보았다.
>
> ```js
> let a = prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
> let b = prompt("덧셈할 두 번째 숫자를 입력해주세요.", 2);
> 
> alert(+a + +b); // 3
> ```
>
> 코드 한 줄 안에서 단항, 이항 `+` 연산자를 한꺼번에 쓰니 조금 웃겨 보인다.

## 2.9 비교연산자

> **보다 큼·작음**: `a > b`, `a < b`.
>
> **보다 크거나·작거나 같음**: `a >= b`, `a <= b`.
>
> **같음(동등)**: `a == b`. 등호 `=`가 두 개 연달아 오는 것에 유의하자. `a = b`와 같이 등호가 하나일 때는 할당을 의미한다.
>
> **같지 않음(부등)**: 같지 않음을 나타내는 수학 기호 `≠`는 자바스크립트에선 `a != b`로 나타낸다. 할당연산자 `=` 앞에 느낌표 `!`를 붙여서 표시한다.

### 불린형 반환

> 다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환하며, 반환 값은 불린형입니다.
>
> `true`가 반환되면, ‘긍정’, ‘참’, '사실’을 의미한다.
>
> `false`가 반환되면, ‘부정’, ‘거짓’, '사실이 아님’을 의미한다.

```js
alert( 2 > 1 );  // true
alert( 2 == 1 ); // false
alert( 2 != 1 ); // true
```

반환된 불린값은 다른 여타 값처럼 변수에 할당 할 수 있다.

```js
let result = 5 > 4; // 비교 결과를 변수에 할당
alert( result ); // true
```



### 문자열 비교

> 자바스크립트는 `'사전’순으로 문자열을 비교한다.` '사전편집(lexicographical)'순 이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단된다.

실제 단어를 사전에 실을 때 단어를 구성하는 문자 하나하나를 비교하여 등재 순서를 정하는 것과 같이 자바스크립트도 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교한다.

```js
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

> 문자열 비교 시 적용되는 알고리즘은 다음과 같다.
>
> 1. 두 문자열의 첫 글자를 비교한다.
> 2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료한다.
> 3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교한다.
> 4. 글자 간 비교가 끝날 때까지 이 과정을 반복한다.
> 5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론낸다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 낸다.
>
> 예시의 `'Z' > 'A'`는 위 알고리즘의 첫 번째 단계에서 비교 결과가 도출된다. 반면, 문자열 `"Glow"`와 `"Glee"`는 복수의 문자로 이루어진 문자열이기 때문에, 아래와 같은 순서로 문자열 비교가 이뤄진다.
>
> 1. `G`는 `G`와 같다.
> 2. `l`은 `l`과 같다.
> 3. `o`는 `e`보다 크기 때문에 여기서 비교가 종료되고, `o`가 있는 첫 번째 문자열 `"Glow"`가 더 크다는 결론이 도출된다.

**정확히는 사전순이 아니라 `유니코드 순`이다.**

자바스크립트의 문자열 비교 알고리즘은 사전이나 전화번호부에서 사용되는 정렬 알고리즘과 아주 유사하지만, 완전히 같진 않는데,차이점 중 하나는 자바스크립트는 대·소문자를 따진다는 것이다. 대문자 `"A"`와 소문자 `"a"`를 비교했을 때 소문자 `"a"`가 더 크다. 자바스크립트 내부에서 사용되는 인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖기 때문이다.

## 다른 형을 가진 값 간의 비교

비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 `숫자형`으로 바꾼다.

```js
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행된다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행된다.
```

불린값의 경우 `true`는 `1`, `false`는 `0`으로 변환된 후 비교가 이뤄진다.

```js
alert( true == 1 ); // true
alert( false == 0 ); // true
```

**흥미로운 상황**

> 같이 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있다.
>
> 1. 동등 비교(`==`) 시 true를 반환함
> 2. 논리 평가 시 값 하나는 `true`, 다른 값 하나는 `false`를 반환함
>
> ```js
> let a = 0;
> alert( Boolean(a) ); // false
> 
> let b = "0";
> alert( Boolean(b) ); // true
> 
> alert(a == b); // true!
> ```
>
> 두 값을 비교했을 때 참이 반환되는데, 값을 논리 평가한 후 비교하면 하나는 거짓이 반환된다는 점이 당황스럽다. 하지만, 자바스크립트의 관점에선 이런 결과가 아주 자연스러운데, 동등 비교 연산자 `==`는 (예시에서 문자열 `"0"`을 숫자 `0`으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문이다.

## 일치 연산자

equality operator(동등연산자) `==`은 `0`과 `false`를 구별하지 못한다.

```js
alert( 0 == false ); // true
```

피연산자가 빈 문자열일 때도 같은 문제가 발생한다.

```js
alert( '' == false ); // true
```

이런 문제는 동등 연산자 `==`가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생한다. 빈 문자열과 `false`는 숫자형으로 변환하면 0이 된다.

그렇다면 `0`과 `false`는 어떻게 구별할 수 있을까?

**일치 연산자(strict equality operator) `===`를 사용하면 형 변환 없이 값을 비교할 수 있다.**

일치 연산자는 `엄격한(strict) 동등 연산자`다. **`자료형의 동등 여부까지 검사`**하기 때문에, 피연산자 `a`와 `b`의 형이 다를 경우 `a === b`는 `false`를 즉시 반환한다.

```js
alert( 0 === false ); // false, 피연산자의 형이 다르기 때문이다.
```

일치 연산자 `===`가 동등 연산자 `==`의 엄격한 형태인 것처럼 “불일치” 연산자 `!==`는 부등 연산자 `!=`의 엄격한 형태다.

일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여준다.

## null이나 undefined와 비교하기

`null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않은 일들이 발생한다.

> > **일치 연산자 `===`를 사용하여 `null`과 `undefined`를 비교**
> >
> > 두 값의 자료형이 다르기 때문에 일치 비교 시 `거짓이 반환`된다.
> >
> > ```js
> > alert( null === undefined ); // false
> > ```
>
> > **동등 연산자 `==`를 사용하여 `null`과 `undefined`를 비교**
> >
> > 동등 연산자를 사용해 `null`과 `undefined`를 비교하면 특별한 규칙이 적용돼 `true`가 반환된다. 동등 연산자는 `null`과 `undefined`를 '각별한 커플’처럼 취급한다. 두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못한다.
> >
> > ```js
> > alert( null == undefined ); // true
> > ```
>
> > **산술 연산자나 기타 비교 연산자 `< > <= >=`를 사용하여 `null`과 `undefined`를 비교**
> >
> > `null`과 `undefined`는 숫자형으로 변환됩니다. `null`은 `0`, `undefined`는 `NaN`으로 변합니다.

### null vs 0

`null`과 0을 비교해보면

```js
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

위의 비교 결과는 논리에 맞지 않는다. (3)에서 `null`은 `0`보다 크거나 같다고 했기 때문에, (1)이나 (2) 중 하나는 참이어야 하는데 둘 다 거짓을 반환하고 있다.

**이는 동등 연산자 `==`와 기타 비교 연산자 `> < >= <=`의 동작 방식이 다르기 때문이다. (1)에서 `null > 0`이 거짓을, (3)에서 `null >= 0`이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) `null`이 숫자형으로 변환돼 `0`이 되기 때문이다.**

**그런데 동등 연산자 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않는다. `undefined`와 `null`을 비교하는 경우에만 `true`를 반환하고, 그 이외의 경우(`null`이나 `undefined`를 다른 값과 비교할 때)는 무조건 `false`를 반환한다. 이런 이유 때문에 (2)는 거짓을 반환한다.**



### 비교가 불가능한 undefined

**`undefined`를 다른 값과 비교해서는 안 됩니다.**

```js
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

위 예시의 결과를 보면 `undefined`는 항상 `false`를 반환하고 있다.

이런 결과는 아래와 같은 이유 때문에 발생한다.

- `(1)`과`(2)`에선 `undefined`가 `NaN`으로 변환되는데(숫자형으로의 변환), `NaN`이 피연산자인 경우 비교 연산자는 항상 `false`를 반환한다.
- `undefined`는 `null`이나 `undefined`와 같고, 그 이외의 값과는 같지 않기 때문에 `(3)`은 `false`를 반환한다.

### [함정 피하기](https://ko.javascript.info/comparison#ref-678)

- 일치 연산자 `===`를 제외한 비교 연산자의 피연산자에 `undefined`나 `null`이 오지 않도록 특별히 주의하자.
- 또한, `undefined`나 `null`이 될 가능성이 있는 변수가 `>= > < <=`의 피연산자가 되지 않도록 주의하자.
- 만약 변수가 `undefined`나 `null`이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가해서 사용하자.

## 요약

- 비교 연산자는 불린값을 반환한다.
- 문자열은 문자 단위로 비교되는데, 이때 비교 기준은 '사전’순입니다.
- 서로 다른 타입의 값을 비교할 땐 숫자형으로 형 변환이 이뤄지고 난 후 비교가 진행된다(일치 연산자는 제외).
- `null`과 `undefined`는 동등 비교(`==`) 시 서로 같지만 다른 값과는 같지 않다.
- `null`이나 `undefined`가 될 확률이 있는 변수가 `>` 또는 `<`의 피연산자로 올 때는 주의하자. `null/undefined` 여부를 확인하는 코드를 따로 추가하는 습관을 들이길 권장한다.

> **quiz**
>
> 아래 표현식들의 결과를 예측해보세요.
>
> ```js
> 5 > 4
> "apple" > "pineapple"
> "2" > "12"
> undefined == null
> undefined === null
> null == "\n0\n"
> null === +"\n0\n"
> ```

> 정답
>
> ```js
> 5 > 4 → true
> "apple" > "pineapple" → false
> "2" > "12" → true
> undefined == null → true
> undefined === null → false
> null == "\n0\n" → false
> null === +"\n0\n" → false
> ```
>
> 해설:
>
> 1. 명백히 true다.
> 2. 문자열의 비교는 사전순서가 기준이므로 false입니다. `"a"`는 `"p"`보다 작다.
> 3. 두 피연산자는 문자열이므로, 사전순으로 비교가 이뤄지며, 왼쪽 피연산자의 첫 번째 글자 `"2"`는 오른쪽 피연산자의 첫 번째 글자 `"1"`보다 크다.
> 4. `null`과 `undefined`는 같다.
> 5. 일치 연산자는 형도 체크한다. 형이 다르면 false가 반환된다.
> 6. `null`은 오직 `undefined`와 같다.
> 7. 형이 다르므로 false가 반환된다.

## 2.10 if와 '?'를 사용한 조건 처리

## 'if’문

`if(...)`문은 괄호 안에 들어가는 조건을 평가하는데, 그 결과가 `true`이면 코드 블록이 실행된다.

```js
let year = prompt('ECMAScript-2015 명세는 몇 년도에 출판되었을까요?', '');

if (year == 2015) alert( '정답입니다!' );
```

위 예시에선 조건(`year == 2015`)이 간단한 경우만 다뤘는데, 조건문은 더 복잡할 수도 있다.

조건이 `true`일 때 복수의 문을 실행하고 싶다면 중괄호로 코드 블록을 감싸야 한다.

```js
if (year == 2015) {
  alert( "정답입니다!" );
  alert( "아주 똑똑하시네요!" );
}
```

`if`문을 쓸 때는 조건이 참일 경우 실행되는 구문이 단 한 줄이더라도 중괄호 `{}`를 사용해 코드를 블록으로 감싸는 것을 권장하는데 이렇게 하면 코드 가독성이 증가하기 때문이다.

## 불린형으로의 변환

`if (…)` 문은 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환한다.

ㅇㅜ선 형변환 규칙을 보면, 

- 숫자 `0`, 빈 문자열`""`, `null`, `undefined`, `NaN`은 불린형으로 변환 시 모두 `false`가 된다. 이런 값들은 ‘falsy(거짓 같은)’ 값이라고 부른다.
- 이 외의 값은 불린형으로 변환시 `true`가 되므로 ‘truthy(참 같은)’ 값이라고 부른다.

이 규칙에 따르면 아래 예시의 코드 블록은 절대 실행되지 않는다.

```js
if (0) { // 0은 falsy입니다.
  ...
}
```

아래 예시의 코드 블록은 항상 실행된다.

```js
if (1) { // 1은 truthy입니다.
  ...
}
```

아래와 같이 평가를 통해 확정된 불린값을 `if`문에 전달할 수도 있다.

```js
let cond = (year == 2015); // 동등 비교를 통해 true/false 여부를 결정합니다.

if (cond) {
  ...
}
```

## 'else’절

`if`문엔 `else` 절을 붙일 수 있다. `else` 뒤에 이어지는 코드 블록은 조건이 거짓일 때 실행된다.

```js
let year = prompt('ECMAScript-2015 명세는 몇 년도에 출판되었을까요?', '');

if (year == 2015) {
  alert( '정답입니다!' );
} else {
  alert( '오답입니다!' ); // 2015 이외의 값을 입력한 경우
}
```

## 'else if’로 복수 조건 처리하기

```js
let year = prompt('ECMAScript-2015 명세는 몇 년도에 출판되었을까요?', '');

if (year < 2015) {
  alert( '숫자를 좀 더 올려보세요.' );
} else if (year > 2015) {
  alert( '숫자를 좀 더 내려보세요.' );
} else {
  alert( '정답입니다!' );
}
```

위 예시에서, 자바스크립트는 조건 `year < 2015`를 먼저 확인하고, 이 조건이 거짓이라면 다음 조건 `year > 2015`를 확인한다. 이 조건 또한 거짓이라면 `else` 절 내의 `alert`를 실행한다.

`else if` 블록을 더 많이 붙이는 것도 가능하다. 마지막에 붙는 `else`는 필수가 아닌 선택 사항이다.

## 조건부 연산자 ‘?’

조건에 따라 다른 값을 변수에 할당해줘야 할 때가 있다.

```js
let accessAllowed;
let age = prompt('나이를 입력해 주세요.', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
```

'물음표(question mark) 연산자’라고도 불리는 '조건부(conditional) 연산자’를 사용하면 위 예시를 더 짧고 간결하게 변형할 수 있다.

조건부 연산자는 물음표`?`로 표시한다. 피연산자가 세 개이기 때문에 조건부 연산자를 `'삼항(ternary) 연산자’`라고 부르는 사람도 있다. 참고로, 자바스크립트에서 피연산자가 3개나 받는 연산자는 조건부 연산자가 유일하다.

```js
let result = condition ? value1 : value2;
```

평가 대상인 `condition`이 truthy라면 `value1`이, 그렇지 않으면 `value2`가 반환된다.

```js
let accessAllowed = (age > 18) ? true : false;
```

`age > 18` 주위의 괄호는 생략 가능하다. 물음표 연산자는 우선순위가 낮으므로 비교 연산자 `>`가 실행되고 난 뒤에 실행된다.

아래 예시는 위 예시와 동일하게 동작한다.

```js
// 연산자 우선순위 규칙에 따라, 비교 연산 'age > 18'이 먼저 실행됩니다.
// (조건문을 괄호로 감쌀 필요가 없습니다.)
let accessAllowed = age > 18 ? true : false;
```

괄호가 있으나 없으나 차이는 없지만, 코드의 가독성 향상을 위해 괄호를 사용할 것을 권장한다.

비교 연산자 자체가 `true`나 `false`를 반환하기 때문에 위 예시에서 물음표 연산자를 사용하지 않아도 된다.

```js
// 동일하게 동작함
let accessAllowed = age > 18;
```

## 다중 ‘?’

물음표 연산자`?`를 여러 개 연결하면 복수의 조건을 처리할 수 있다.

```js
let age = prompt('나이를 입력해주세요.', 18);

let message = (age < 3) ? '아기야 안녕?' :
  (age < 18) ? '안녕!' :
  (age < 100) ? '환영합니다!' :
  '나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';

alert( message );
```

> 1. 첫 번째 물음표에선 조건문 `age < 3`을 검사한다.
> 2. 그 결과가 참이면 `'아기야 안녕?'`를 반환한다. 그렇지 않다면 첫 번째 콜론 `":"`에 이어지는 조건문 `age < 18`을 검사한다.
> 3. 그 결과가 참이면 `'안녕!'`를 반환한다. 그렇지 않다면 다음 콜론 `":"`에 이어지는 조건문 `age < 100`을 검사한다.
> 4. 그 결과가 참이면 `'환영합니다!'`를 반환한다. 그렇지 않다면 마지막 콜론 `":"` 이후의 표현식인 `'나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!'`를 반환한다.

`if..else`를 사용하면 위 예시를 아래와 같이 변형할 수 있다.

```js
if (age < 3) {
  message = '아기야 안녕?';
} else if (age < 18) {
  message = '안녕!';
} else if (age < 100) {
  message = '환영합니다!';
} else {
  message = '나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';
}
```

## 부적절한 ‘?’

물음표`?`를 `if` 대용으로 쓰는 경우가 종종 있다.

```js
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

(company == 'Netscape') ?
   alert('정답입니다!') : alert('오답입니다!');
```

조건 `company == 'Netscape'`의 검사 결과에 따라 `?` 뒤에 이어지는 첫 번째 혹은 두 번째 표현식이 실행되어 얼럿 창이 뜬다.

위 예시에선 평가 결과를 변수에 할당하지 않고, 결과에 따라 실행되는 표현식이 달라지도록 하였다.

그런데 **이런 식으로 물음표 연산자를 사용하는 것은 좋지 않다.**

개발자 입장에선 `if`문을 사용할 때 보다 코드 길이가 짧아진다는 점 때문에 물음표`?`를 `if` 대용으로 쓰는 게 매력적일 순 있다. 하지만 이렇게 코드를 작성하면 **가독성이 떨어진다.**

아래는 `if`를 사용해 변형한 코드다.

```js
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

if (company == 'Netscape') {
  alert('정답입니다!');
} else {
  alert('오답입니다!');
}
```

코드를 읽을 때 우리의 눈은 수직으로 움직이는데, 수평으로 길게 늘어진 코드보단 여러 줄로 나뉘어 작성된 코드 블록이 더 읽기 쉽다.

`물음표 연산자`?`는 조건에 따라 반환 값을 달리하려는 목적으로 만들어졌다.` 이런 목적에 부합하는 곳에 물음표를 사용하고, 여러 분기를 만들어 처리할 때는 `if`를 사용하자.

## 2.11 논리 연산자

자바스크립트엔 세 종류의 논리 연산자 `||`(OR), `&&`(AND), `!`(NOT)이 있다.

‘OR’ 연산자는 두 개의 수직선 기호로 만들 수 있다.

```
result = a || b;
```

전통적인 프로그래밍에서 OR 연산자는 불린값을 조작하는 데 쓰인다. 인수 중 하나라도 `true`이면 `true`를 반환하고, 그렇지 않으면 `false`를 반환한다.

자바스크립트의 OR 연산자는 다루긴 까다롭지만 강력한 기능을 제공한다. OR 연산자는 이항 연산자이므로 아래와 같이 네 가지 조합이 가능하다.

```js
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

피연산자가 모두 `false`인 경우를 제외하고 연산 결과는 항상 `true`다.

피연산자가 불린형이 아니면, 평가를 위해 불린형으로 변환된다. 예를 들어, 연산 과정에서 숫자 `1`은 `true`로, 숫자 `0`은 `false`로 바뀐다.

```js
if (1 || 0) { // if( true || false ) 와 동일하게 동작합니다.
  alert( 'truthy!' );
}
```

OR 연산자 `||`은 `if`문에서 자주 사용되며, 주어진 조건 중 *하나라도* `참`인지를 테스트하는 용도로 쓰인다.

```js
let hour = 9;

if (hour < 10 || hour > 18) {
  alert( '영업시간이 아닙니다.' );
}
```

`if`문 안에 여러 가지 조건을 넣을 수 있다.

```js
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( '영업시간이 아닙니다.' ); // 주말이기 때문임
}
```

## 첫 번째 truthy를 찾는 OR 연산자 ‘||’

**`자바스크립트에서만 제공`하는 논리연산자 OR의 '추가’기능이 있다.** 추가 기능은 아래와 같은 알고리즘으로 동작한다.

OR 연산자와 피연산자가 여러 개인 경우:

```js
result = value1 || value2 || value3;
```

> 이때, OR `||`연산자는 다음 순서에 따라 연산을 수행한다.
>
> 1. 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가한다.
> 2. 각 피연산자를 불린형으로 변환한다. 변환 후 그 값이 `true`이면 연산을 멈추고 해당 피연산자의 **변환 전** 원래 값을 반환한다.
> 3. 피연산자 모두를 평가한 경우(모든 피연산자가 `false`로 평가되는 경우)엔 마지막 피연산자를 반환한다.

여기서 핵심은 반환 값이 형 변환을 하지 않은 원래 값이다.

정리해 보면,

**OR `"||"` 연산자를 여러 개 체이닝(chaining) 하면 첫 번째 truthy를 반환한다. 피연산자에 truthy가 하나도 없다면 마지막 피연산자를 반환한다.**

```js
alert( 1 || 0 ); // 1 (1은 truthy임)

alert( null || 1 ); // 1 (1은 truthy임)
alert( null || 0 || 1 ); // 1 (1은 truthy임)

alert( undefined || null || 0 ); // 0 (모두 falsy이므로, 마지막 값을 반환함)
```

이런 OR 연산자의 추가 기능을 이용하면 여러 용도로 OR 연산자를 활용할 수 있다.

1. **변수 또는 표현식으로 구성된 목록에서 첫 번째 truthy 얻기**

   `firstName`, `lastName`, `nickName`이란 변수가 있는데 이 값들은 모두 옵션 값이라고 해보자.

   OR `||`을 사용하면 실제 값이 들어있는 변수를 찾고, 그 값을 보여줄 수 있다. 변수 모두에 값이 없는 경우엔 `익명`를 보여주자.

   ```js
   let firstName = "";
   let lastName = "";
   let nickName = "바이올렛";
   
   alert( firstName || lastName || nickName || "익명"); // 바이올렛
   ```

   모든 변수가 falsy이면 `"익명"`이 출력

2. **단락 평가**

   OR 연산자 `||`가 제공하는 또 다른 기능은 `'short circuit evaluation(단락 평가)'`다.

   위 설명과 같이 OR`||`은 왼쪽부터 시작해서 오른쪽으로 평가를 진행하는데, truthy를 만나면 나머지 값들은 건드리지 않은 채 평가를 멈춘다. 이런 프로세스를 '단락 평가’라고 한다.

   단락 평가의 동작 방식은 두 번째 피연산자가 변수 할당과 같은 `side effect(부수적인 효과)`를 가지는 표현식 일 때 명확히 볼 수 있다.

   아래 예시를 실행하면 두 번째 메시지만 출력된다.

   ```js
   true || alert("not printed");
   false || alert("printed");
   ```

   첫 번째 줄의 `||` 연산자는 `true`를 만나자마자 평가를 멈추기 때문에 `alert`가 실행되지 않는다.

   단락 평가는 연산자 왼쪽 조건이 falsy일 때만 명령어를 실행하고자 할 때 자주 쓰인다.

## && (AND)

두 개의 앰퍼샌드를 연달아 쓰면 AND 연산자 `&&`를 만들 수 있다.

```js
result = a && b;
```

전통적인 프로그래밍에서 AND 연산자는 두 피연산자가 모두가 참일 때 `true`를 반환한다. 그 외의 경우는 `false`를 반환한다.

```js
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

아래는 `if`문과 AND 연산자를 함께 활용한 예제다.

```js
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( '현재 시각은 12시 30분입니다.' );
}
```

OR 연산자와 마찬가지로 AND 연산자의 피연산자도 타입에 제약이 없다.

```js
if (1 && 0) { // 피연산자가 숫자형이지만 논리형으로 바뀌어 true && false가 됩니다.
  alert( "if 문 안에 falsy가 들어가 있으므로 alert창은 실행되지 않습니다." );
}
```

## 첫 번째 falsy를 찾는 AND 연산자 ‘&&’

아래는 AND 연산자와 피연산자가 여러 개인 경우다.

```js
result = value1 && value2 && value3;
```

AND 연산자 `&&`는 아래와 같은 순서로 동작한다.

- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가한다.
- 각 피연산자는 불린형으로 변환된다. 변환 후 값이 `false`이면 평가를 멈추고 해당 피연산자의 **변환 전** 원래 값을 반환한다.
- 피연산자 모두가 평가되는 경우(모든 피연산자가 `true`로 평가되는 경우)엔 마지막 피연산자가 반환된다.

```js
정리해 보자면, AND 연산자는 첫 번째 falsy를 반환한다. 피연산자에 falsy가 없다면 마지막 값을 반환한다.
```

위 알고리즘은 OR 연산자의 알고리즘과 유사하다. 차이점은 AND 연산자가 첫 번째 *falsy*를 반환하는 반면, OR은 첫 번째 *truthy*를 반환한다는 것이다.

```js
// 첫 번째 피연산자가 truthy이면,
// AND는 두 번째 피연산자를 반환합니다.
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// 첫 번째 피연산자가 falsy이면,
// AND는 첫 번째 피연산자를 반환하고, 두 번째 피연산자는 무시합니다.
alert( null && 5 ); // null
alert( 0 && "아무거나 와도 상관없습니다." ); // 0
```

AND 연산자에도 피연산자 여러 개를 연속해서 전달할 수 있다.

```js
alert( 1 && 2 && null && 3 ); // null
```

아래 예시에선 AND 연산자의 피연산자가 모두 truthy이기 때문에 마지막 피연산자가 반환된다.

```js
alert( 1 && 2 && 3 ); // 마지막 값, 3
```

**`&&`의 우선순위가 `||`보다 높다.**

AND 연산자 `&&`의 우선순위는 OR 연산자 `||`보다 높다.

따라서 `a && b || c && d`는 `(a && b) || (c && d)`와 동일하게 동작한다.

**`if`를 ||나 &&로 대체하지 말자.**

```js
let x = 1;

(x > 0) && alert( '0보다 큽니다!' );
```

`&&`의 오른쪽 피연산자는 평가가 `&&` 우측까지 진행되어야 실행된다. 즉, `(x > 0)`이 참인 경우에만 `alert`문이 실행되는데,

위 코드를 if 문을 써서 바꾸면 다음과 같다.

```js
let x = 1;

if (x > 0) alert( '0보다 큽니다!' );
```

`&&`를 사용한 코드가 더 짧긴 하지만 `if`문을 사용한 예시가 코드에서 무엇을 구현하고자 하는지 더 명백히 드러내고, 가독성도 좋다. 그러니 if 조건문이 필요하면 `if`를 사용하고 AND 연산자는 연산자 목적에 맞게 사용하자.

## ! (NOT)

논리 연산자 NOT은 느낌표 `!`를 써서 만들 수 있다. NOT 연산자의 문법은 매우 간단하다.

```js
result = !value;
```

NOT 연산자는 인수를 하나만 받고, 다음 순서대로 연산을 수행한다.

1. 피연산자를 불린형(`true / false`)으로 변환한다.
2. 1에서 변환된 값의 역을 반환한다.

```js
alert( !true ); // false
alert( !0 ); // true
```

**`NOT을 두 개 연달아 사용(`!!`)하면 값을 불린형으로 변환할 수 있습니다.`**

```js
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

이때, 첫 번째 NOT 연산자는 피연산자로 받은 값을 불린형으로 변환한 후 이 값의 역을 반환하고, 두 번째 NOT 연산자는 첫 번째 NOT 연산자가 반환한 값의 역을 반환한다. 이렇게 NOT을 연달아 사용하면 특정 값을 불린형으로 변환할 수 있다.

참고로, 내장 함수 `Boolean`을 사용하면 `!!`을 사용한 것과 같은 결과를 도출할 수 있다.

```js
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

**`NOT` 연산자의 우선순위는 모든 논리 연산자 중에서 가장 높기 때문에 항상 `&&`나 `||` 보다 먼저 실행된다.**

> **quiz**
>
> 사이 범위 확인하기
>
> `age`(나이)가 `14`세 이상 `90`세 이하에 속하는지를 확인하는 `if`문을 작성하세요.
>
> "이상과 이하"는 `age`(나이) 범위에 `14`나 `90`이 포함된다는 의미입니다.
>
> 해답
>
> ```js
> if (age >= 14 && age <= 90)
> ```
>
> **❗if (14 <= age <= 90) 식으로는 정상적으로 동작이 안되는 이유**
>
> > if문의 조건 14<=age<=90에서 연산자는 <=만 쓰였기 때문에, 동일한 연산자는 당연히 동일한 우선순위를 갖기 때문에 좌측부터 실행한다.
> >
> > 따라서 age값에 따라 14<=age는 true 또는 false를 반환한다. 14<=age의 결과값이 true 또는 false이므로 true <= 90, false <= 90 두 가지 경우로 변환이 되고 비교 연산자를 실행하기 위해 형변환이 일어나 true는 1로 false는 0으로 형변환이 된다.
> >
> > 그렇기에, 1과 0 모두 90보다는 작거나 같기 때문에 age값에 무관하게 항상 '환영합니다'를 출력하게 된다.

## 2.12 null 병합 연산자 '??'

**nullish coalescing operator(null 병합 연산자)**는 `??`를 사용하면 짧은 문법으로 여러 피연산자 중 그 값이 ‘확정되어있는’ 변수를 찾을 수 있다.

> `a ?? b`의 평가 결과는 다음과 같다.
>
> - `a`가 `null`도 아니고 `undefined`도 아니면 `a`
> - 그 외의 경우는 `b`

null 병합 연산자 `??`없이 `x = a ?? b`와 동일한 동작을 하는 코드를 작성하면 다음과 같다.

```js
x = (a !== null && a !== undefined) ? a : b;
```

또 다른 예시를 살펴봅시다. `firstName`, `lastName`, `nickName`이란 변수에 사용자 이름이나 별명을 저장하는데, 사용자가 아무런 정보도 입력하지 않는 케이스도 허용한다고 해보자.

화면엔 세 변수 중, 값이 정해진 변수의 값을 출력하는데, 세 변수 모두 값이 정해지지 않았다면 "Anonymous"가 출력되도록 해보자.

이럴 때 null 병합 연산자 `??`를 사용하면 값이 정해진 변수를 간편하게 찾아낼 수 있다.

```js
let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
```

## '??'와 '||'의 차이

null 병합 연산자는 OR 연산자 `||`와 상당히 유사해 보인다. 실제로 위 예시에서 `??`를 `||`로 바꿔도 그 결과는 동일하기까지 하다. 하지만 두 연산자 사이에는 중요한 차이점이 있다.

- `||`는 첫 번째 *truthy* 값을 반환한다.
- `??`는 첫 번째 *정의된(defined)* 값을 반환한다.

`null`과 `undefined`, 숫자 `0`을 구분 지어 다뤄야 할 때 이 차이점은 매우 중요한 역할을 한다.

```js
height = height ?? 100;
```

`height`에 값이 정의되지 않았다면 `height`엔 `100`이 할당된다.

이제 `??`와 `||`을 비교해보자.

```js
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```

`height || 100`은 `height`에 `0`을 할당했지만 `0`을 falsy 한 값으로 취급했기 때문에 `null`이나 `undefined`를 할당한 것과 동일하게 처리된다. 따라서 `height || 100`의 평가 결과는 `100`이다.

반면 `height ?? 100`의 평가 결과는 `height`가 정확하게 `null`이나 `undefined`일 경우에만 `100`이 된다. 예시에선 `height`에 `0`이라는 값을 할당했기 때문에 얼럿창엔 `0`이 출력된다.

**이런 특징 때문에 높이처럼 `0`이 할당될 수 있는 변수를 사용해 기능을 개발할 땐 `||`보다 `??`가 적합하다.**

## 연산자 우선순위

[`??`의 연산자 우선순위](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table)는 `5`로 꽤 낮다. 따라서 `??`는 `=`와 `?` 보다는 먼저, 대부분의 연산자보다는 나중에 평가된다.

그렇기 때문에 복잡한 표현식 안에서 `??`를 사용해 값을 하나 선택할 땐 괄호를 추가하는 게 좋다.

```js
let height = null;
let width = null;

// 괄호를 추가!
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
```

그렇지 않으면 `*`가 `??`보다 우선순위가 높기 때문에 `*`가 먼저 실행된다.

```js
// 원치 않는 결과
let area = height ?? (100 * width) ?? 50;
```

`??`엔 자바스크립트 언어에서 규정한 또 다른 제약사항이 있다.

**안정성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하지 못한다.**

아래 예시를 실행하면 문법 에러가 발생한다.

```js
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
```

이 제약에 대해선 아직 논쟁이 많긴 하지만 사람들이 `||`를 `??`로 바꾸기 시작하면서 만드는 실수를 방지하고자 명세서에 제약이 추가된 상황이다.

제약을 피하려면 **괄호**를 반드시 사용하자.

```js
let x = (1 && 2) ?? 3; // 제대로 동작합니다.

alert(x); // 2
```

> ### 요약
>
> null 병합 연산자 `??`를 사용하면 피연산자 중 ‘값이 할당된’ 변수를 빠르게 찾을 수 있다.
>
> `??`는 변수에 기본값을 할당하는 용도로 사용할 수 있다.
>
> ```js
> height = height ?? 100;
> ```
>
> `??`의 연산자 우선순위는 대다수의 연산자보다 낮고 `?`와 `=` 보다는 높다.
>
> 괄호 없이 `??`를 `||`나 `&&`와 함께 사용하는 것은 금지되어 있다.

## 2.13 while과 for 반복문

*loop(반복문)* 을 사용하면 동일한 코드를 여러 번 반복할 수 있다.

## ‘while’ 반복문

```js
while (condition) {
  // 코드
  // '반복문 본문(body)'이라 불림
}
```

`condition`(조건)이 truthy 이면 반복문 본문의 `코드`가 실행된다.

아래 반복문은 조건 `i < 3`을 만족할 동안 `i`를 출력해준다.

```js
let i = 0;
while (i < 3) { // 0, 1, 2가 출력된다.
  alert( i );
  i++;
}
```

반복문 본문이 한 번 실행되는 것을 *iteration(반복)*이라고 부른다. 위 예시에선 반복문이 세 번의 이터레이션을 만든다.

`i++`가 없었다면 이론적으로 반복문이 영원히 반복되었을 것이다. 그런데 브라우저는 이런 무한 반복을 멈추게 해주는 실질적인 수단을 제공한다. 서버 사이드 자바스크립트도 이런 수단을 제공해 주므로 무한으로 반복되는 프로세스를 죽일 수 있다.

반복문 조건엔 비교뿐만 아니라 모든 종류의 표현식, 변수가 올 수 있다. 조건은 `while`에 의해 평가되고, 평가 후엔 불린값으로 변경된다.

아래 예시에선 `while (i != 0)`을 짧게 줄여 `while (i)`로 만들어보았다.

```js
let i = 3;
while (i) { // i가 0이 되면 조건이 falsy가 되므로 반복문이 멈춥니다.
  alert( i );
  i--;
}
```

**본문이 한 줄이면 대괄호를 쓰지 않아도 된다.**

반복문 본문이 한 줄짜리 문이라면 대괄호 `{…}`를 생략할 수 있다.

```js
let i = 3;
while (i) alert(i--);
```

## do…while’ 반복문

`do..while` 문법을 사용하면 `condition`을 반복문 본문 *아래*로 옮길 수 있다.

```js
do {
  // 반복문 본문
} while (condition);
```

이때 본문이 먼저 실행되고, 조건을 확인한 후 조건이 truthy인 동안엔 본문이 계속 실행된다.

예시:

```js
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

`do..while` 문법은 조건이 truthy 인지 아닌지에 상관없이, 본문을 **최소한 한번**이라도 실행하고 싶을 때만 사용해야한다. 대다수의 일반적인 상황에선 `do..while`보다 `while(…) {…}`이 적합하다.

## [‘for’ 반복문](https://ko.javascript.info/while-for#ref-1968)

`for` 반복문은 `while` 반복문보다는 복잡하지만 가장 많이 쓰이는 반복문이다.

```js
for (begin; condition; step) {
  // ... 반복문 본문 ...
}
```

`for`문을 구성하는 각 요소가 무엇을 의미하는지 알아보자. 아래 반복문을 실행하면 `i`가 `0`부터 `3`이 될 때까지(단, `3`은 포함하지 않음) `alert(i)`가 호출된다.

```js
for (let i = 0; i < 3; i++) { // 0, 1, 2가 출력된다.
  alert(i);
}
```

이제 `for`문의 구성 요소를 하나씩 살펴보자.

| 구성 요소 |            |                                                             |
| --------- | ---------- | ----------------------------------------------------------- |
| begin     | `i = 0`    | 반복문에 진입할 때 단 한 번 실행된다.                       |
| condition | `i < 3`    | 반복마다 해당 조건이 확인됩니다. false이면 반복문을 멈춘다. |
| body      | `alert(i)` | condition이 truthy일 동안 계속해서 실행된다.                |
| step      | `i++`      | 각 반복의 body가 실행된 이후에 실행된다.                    |

일반적인 반복문 알고리즘은 다음과 같다.

```js
begin을 실행함
→ (condition이 truthy이면 → body를 실행한 후, step을 실행함)
→ (condition이 truthy이면 → body를 실행한 후, step을 실행함)
→ (condition이 truthy이면 → body를 실행한 후, step을 실행함)
→ ...
```

`begin`이 한 차례 실행된 이후에, `condition` 확인과 `body`, `step`이 계속해서 반복 실행된다.

```js
// for (let i = 0; i < 3; i++) alert(i)

// begin을 실행함
let i = 0
// condition이 truthy이면 → body를 실행한 후, step을 실행함
if (i < 3) { alert(i); i++ }
// condition이 truthy이면 → body를 실행한 후, step을 실행함
if (i < 3) { alert(i); i++ }
// condition이 truthy이면 → body를 실행한 후, step을 실행함
if (i < 3) { alert(i); i++ }
// i == 3이므로 반복문 종료
```

**인라인 변수 선언**

지금까진 ‘카운터’ 변수 `i`를 반복문 안에서 선언하였다. 이런 방식을 ‘인라인’ 변수 선언이라고 부른다. 이렇게 선언한 변수는 반복문 안에서만 접근할 수 있다.

```js
for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // Error: i is not defined
```

인라인 변수 선언 대신, 정의되어있는 변수를 사용할 수도 있다.

```js
let i = 0;

for (i = 0; i < 3; i++) { // 기존에 정의된 변수 사용
  alert(i); // 0, 1, 2
}

alert(i); // 3, 반복문 밖에서 선언한 변수이므로 사용할 수 있음
```

### 구성 요소 생략하기

`for`문의 구성 요소를 생략하는 것도 가능하고, 또한 반복문이 시작될 때 아무것도 할 필요가 없으면 `begin`을 생략하는 것이 가능하다.

```js
let i = 0; // i를 선언하고 값도 할당하였다.

for (; i < 3; i++) { // 'begin'이 필요하지 않기 때문에 생략하였다.
  alert( i ); // 0, 1, 2
}
```

`step` 역시 생략할 수 있다.

```js
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```

위와 같이 `for`문을 구성하면 `while (i < 3)`과 동일해진다.

모든 구성 요소를 생략할 수도 있는데, 이렇게 되면 무한 반복문이 만들어진다.

```js
for (;;) {
  // 끊임 없이 본문이 실행된다.
}
```

`for`문의 구성요소를 생략할 때 주의할 점은 두 개의 `;` 세미콜론을 꼭 넣어주어야 한다는 점인데, 하나라도 없으면 문법 에러가 발생한다.

## 반복문 빠져나오기

대개는 반복문의 조건이 falsy가 되면 반복문이 종료된다.

그런데 특별한 지시자인 `break`를 사용하면 언제든 원하는 때에 반복문을 빠져나올 수 있다.

아래 예시의 반복문은 사용자에게 일련의 숫자를 입력하도록 안내하고, 사용자가 아무런 값도 입력하지 않으면 반복문을 '종료’한다.

```js
let sum = 0;

while (true) {

  let value = +prompt("숫자를 입력하세요.", '');

  if (!value) break; // (*)

  sum += value;

}
alert( '합계: ' + sum );
```

`(*)`로 표시한 줄에 있는 `break`는 사용자가 아무것도 입력하지 않거나 `Cancel`버튼을 눌렀을 때 활성화된다. 이때 반복문이 즉시 중단되고 제어 흐름이 반복문 아래 첫 번째 줄로 이동한다. 여기선 `alert`가 그 첫 번째 줄이 되겠다.

반복문의 시작 지점이나 끝 지점에서 조건을 확인하는 것이 아니라 본문 가운데 혹은 본문 여러 곳에서 조건을 확인해야 하는 경우, '무한 반복문 + `break`’ 조합을 사용하면 좋다.

## 다음 반복으로 넘어가기

`continue` 지시자는 `break`의 '가벼운 버전’이다. `continue`는 전체 반복문을 멈추지 않는다. 대신에 현재 실행 중인 이터레이션을 멈추고 반복문이 다음 이터레이션을 강제로 실행시키도록 한다(조건을 통과할 때).

`continue`는 현재 반복을 종료시키고 다음 반복으로 넘어가고 싶을 때 사용할 수 있다.

아래 반복문은 `continue`를 사용해 홀수만 출력한다.

```js
for (let i = 0; i < 10; i++) {

  // 조건이 참이라면 남아있는 본문은 실행되지 않는다.
  if (i % 2 == 0) continue;

  alert(i); // 1, 3, 5, 7, 9가 차례대로 출력 됨
}
```

`i`가 짝수이면 `continue`가 본문 실행을 중단시키고 다음 이터레이션이 실행되게 한다(`i`가 하나 증가하고, 다음 반복이 실행 됨). 따라서 `alert` 함수는 인수가 홀수일 때만 호출된다.

**`continue`는 중첩을 줄이는 데 도움을 준다.**

홀수를 출력해주는 예시는 아래처럼 생길 수도 있다.

```js
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }
}
```

기술적인 관점에서 봤을 때, 이 예시는 위쪽에 있는 예시와 동일하다. `continue`를 사용하는 대신 코드를 `if` 블록으로 감싼 점만 다르다.

그런데 이렇게 코드를 작성하면 부작용으로 중첩 레벨(대괄호 안의 `alert` 호출)이 하나 더 늘어난다. `if` 안의 코드가 길어진다면 전체 가독성이 떨어질 수 있다.

삼항연산자 **‘?’ 오른쪽엔 `break`나 `continue`가 올 수 없다.**

표현식이 아닌 문법 구조(syntax construct)는 삼항 연산자 `?`에 사용할 수 없다는 점을 항상 유의해야한다. 특히 `break`나 `continue` 같은 지시자는 삼항 연산자에 사용하면 안된다.

```js
if (i > 5) {
  alert(i);
} else {
  continue;
}
```

위의 코드를 삼항연산자를 이용하여 아래와 같이 변경하면 오류가 발생 된다.

```js
(i > 5) ? alert(i) : continue; // 여기에 continue를 사용하면 안 된다.
```

이런 코드는 문법 에러를 발생시킨다.

**이는 물음표 연산자 `?`를 `if`문 대용으로 쓰지 말아야 하는 이유 중 하나다.**

## break/continue와 레이블

여러 개의 중첩 반복문을 한 번에 빠져나와야 하는 경우가 종종 생기곤 한다.

`i`와 `j`를 반복하면서 프롬프트 창에 `(0,0)`부터 `(2,2)`까지를 구성하는 좌표 `(i, j)`를 입력하게 해주는 예시는 아래와 같다.

```js
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`(${i},${j})의 값`, '');

    // 여기서 멈춰서 아래쪽의 `완료!`가 출력되게 하려면 어떻게 해야 할까?
  }
}

alert('완료!');
```

사용자가 `Cancel` 버튼을 눌렀을 때 반복문을 중단시킬 방법이 필요하다.

`input` 아래에 평범한 `break` 지시자를 사용하면 안쪽에 있는 반복문만 빠져나올 수 있다. 이것만으론 충분하지 않다(중첩 반복문을 포함한 반복문 두 개 모두를 빠져나와야 하기 때문이다). 이럴 때 레이블을 사용할 수 있다.

*레이블(label)* 은 반복문 앞에 콜론과 함께 쓰이는 식별자다.

```js
labelName: for (...) {
  ...
}
```

반복문 안에서 `break <labelName>`문을 사용하면 레이블에 해당하는 반복문을 빠져나올 수 있다.

```js
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`(${i},${j})의 값`, '');

    // 사용자가 아무것도 입력하지 않거나 Cancel 버튼을 누르면 두 반복문 모두를 빠져나온다.
    if (!input) break outer; // (*)

    // 입력받은 값을 가지고 무언가를 함
  }
}
alert('완료!');
```

위 예시에서 `break outer`는 `outer`라는 레이블이 붙은 반복문을 찾고, 해당 반복문을 빠져나오게 해준다.

따라서 제어 흐름이 `(*)`에서 `alert('완료!')`로 바로 바뀐다.

레이블을 별도의 줄에 써주는 것도 가능하다.

```js
outer:
for (let i = 0; i < 3; i++) { ... }
```

`continue` 지시자를 레이블과 함께 사용하는 것도 가능하다. 두 가지를 같이 사용하면 레이블이 붙은 반복문의 다음 이터레이션이 실행된다.

**레이블은 마음대로 '점프’할 수 있게 해주지 않는다.**

레이블을 사용한다고 해서 원하는 곳으로 마음대로 점프할 수 있는 것은 아니다.

아래 예시처럼 레이블을 사용하는 것은 불가능하다.

```js
break label; // 아래 for 문으로 점프할 수 없다.

label: for (...)
```

`break`와 `continue`는 반복문 안에서만 사용할 수 있고, 레이블은 반드시 `break`이나 `continue` 지시자 위에 있어야 한다.

## 요약

- `while` – 각 반복이 시작하기 전에 조건을 확인합니다.
- `do..while` – 각 반복이 끝난 후에 조건을 확인합니다.
- `for (;;)` – 각 반복이 시작하기 전에 조건을 확인합니다. 추가 세팅을 할 수 있습니다.

‘무한’ 반복문은 보통 `while(true)`를 써서 만든다. 무한 반복문은 여타 반복문과 마찬가지로 `break` 지시자를 사용해 멈출 수 있다.

현재 실행 중인 반복에서 더는 무언가를 하지 않고 다음 반복으로 넘어가고 싶다면 `continue` 지시자를 사용할 수 있다.

반복문 앞에 레이블을 붙이고, `break/continue`에 이 레이블을 함께 사용할 수 있다. 레이블은 중첩 반복문을 빠져나와 바깥의 반복문으로 갈 수 있게 해주는 유일한 방법이다.

## 2.14 switch문

복수의 `if` 조건문은 `switch`문으로 바꿀 수 있는데, `switch`문을 사용한 비교법은 특정 변수를 다양한 상황에서 비교할 수 있게 해준다. 코드 자체가 비교 상황을 잘 설명한다는 장점도 있다.

## 문법

`switch`문은 하나 이상의 `case`문으로 구성되며, 대개 `default`문도 있지만, 이는 다른 프로그래밍 언어와는 다르게 필수는 아니다.

```js
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```

- 변수 `x`의 값과 첫 번째 `case`문의 값 `'value1'`를 일치 비교한 후, 두 번째 `case`문의 값 `'value2'`와 비교한다. 이런 과정은 계속 이어진다.
- `case`문에서 변수 `x`의 값과 일치하는 값을 찾으면 해당 `case` 문의 아래의 코드가 실행된다. 이때, `break`문을 만나거나 `switch` 문이 끝나면 코드의 실행은 멈춘다.
- 값과 일치하는 `case`문이 없다면, `default`문 아래의 코드가 실행된다.(`default` 문이 있는 경우)

```js
let a = 2 + 2;

switch (a) {
  case 3:
    alert( '비교하려는 값보다 작습니다.' );
    break;
  case 4:
    alert( '비교하려는 값과 일치합니다.' );
    break;
  case 5:
    alert( '비교하려는 값보다 큽니다.' );
    break;
  default:
    alert( "어떤 값인지 파악이 되지 않습니다." );
}
```

`switch`문은 a의 값인 4와 첫 번째 `case`문의 값인 3을 비교한다. 두 값은 같지 않기 때문에 다음 `case`문으로 넘어간다.

a와 그다음 `case`문의 값인 4는 일치한다. 따라서 `break`문을 만날 때까지 `case 4` 아래의 코드가 실행된다.

**`case`문 안에 `break`문이 없으면 조건에 부합하는지 여부를 따지지 않고 이어지는 `case`문을 실행한다.**

`break`문이 없는 경우 아래의 코드의 결과를 살펴보자.

```js
let a = 2 + 2;

switch (a) {
  case 3:
    alert( '비교하려는 값보다 작습니다.' );
  case 4:
    alert( '비교하려는 값과 일치합니다.' );
  case 5:
    alert( '비교하려는 값보다 큽니다.' );
  default:
    alert( "어떤 값인지 파악이 되지 않습니다." );
}
```

위 예시를 실행하면 아래 3개의 `alert`문이 실행된다.

```js
alert( '비교하려는 값과 일치합니다.' );
alert( '비교하려는 값보다 큽니다.' );
alert( "어떤 값인지 파악이 되지 않습니다." );
```

**`switch/case`문의 인수엔 어떤 표현식이든 올 수 있다.**

`switch`문과 `case`문은 모든 형태의 표현식을 인수로 받는다.

```js
let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("표현식 +a는 1, 표현식 b+1는 1이므로 이 코드가 실행됩니다.");
    break;

  default:
    alert("이 코드는 실행되지 않습니다.");
}
```

표현식 +a를 평가하면 1이 된다. 이 값은 첫 번째 `case`문의 표현식 `b + 1`을 평가한 값(1)과 일치한다. 따라서 첫 번째 `case`문 아래의 코드가 실행된다.

## 여러 개의 "case"문 묶기

코드가 같은 `case`문은 한데 묶을 수 있다.

`case 3`과 `case 5`에서 실행하려는 코드가 같은 경우에 대한 예시다.

```js
let a = 3;

switch (a) {
  case 4:
    alert('계산이 맞습니다!');
    break;

  case 3: // (*) 두 case문을 묶음
  case 5:
    alert('계산이 틀립니다!');
    alert("수학 수업을 다시 들어보는걸 권유 드립니다.");
    break;

  default:
    alert('계산 결과가 이상하네요.');
}
```

`case 3`과 `case 5`는 동일한 메시지를 보여준다.

`switch/case`문에서 `break`문이 없는 경우엔 조건에 상관없이 다음 `case`문이 실행되는 부작용이 발생한다. 위 예시에서 `case 3`이 참인 경우엔 `(*)`로 표시한 줄 아래의 코드가 실행되는데, 그 아래 줄엔 `case 5`가 있고 `break`문도 없기 때문에 12번째 줄의 `break`문을 만날 때까지 코드는 계속 실행된다.

## 자료형의 중요성

switch문은 일치 비교로 조건을 확인힌다. 비교하려는 값과 `case`문의 값의 형과 값이 같아야 해당 `case`문이 실행된다.

예시를 통해 switch문에서 자료형이 얼마나 중요한지 알수있다.

```js
let arg = prompt("값을 입력해주세요.");
switch (arg) {
  case '0':
  case '1':
    alert( '0이나 1을 입력하셨습니다.' );
    break;

  case '2':
    alert( '2를 입력하셨습니다.' );
    break;

  case 3:
    alert( '이 코드는 절대 실행되지 않습니다!' );
    break;
  default:
    alert( '알 수 없는 값을 입력하셨습니다.' );
}
```

> 1.`0`이나 `1`을 입력한 경우엔 첫 번째 `alert`문이 실행된다.
>
> 2.`2`를 입력한 경우엔 두 번째 `alert`문이 실행된다.
>
> 3.`3`을 입력하였더라도 세 번째 `alert`문은 실행되지 않는다. 앞서 배운 바와 같이 `prompt` 함수는 사용자가 입력 필드에 기재한 값을 문자열로 변환해 반환하기 때문에 숫자 `3`을 입력하더라도 `prompt` 함수는 문자열 `'3'`을 반환한다. 그런데 세 번째 `case`문에선 사용자가 입력한 값과 숫자형 3을 비교하므로, 형 자체가 다르기 때문에 `case 3` 아래의 코드는 절대 실행되지 않는다. 대신 `default`문이 실행된다.

#### 2.15 함수

함수는 프로그램을 구성하는 주요 '구성 요소(building block)'다. 함수를 이용하면 중복 없이 유사한 동작을 하는 코드를 여러 번 호출할 수 있다.

## 함수 선언

*함수 선언(function declaration)* 방식을 이용하면 함수를 만들 수 있다.(함수 선언 방식은 함수 선언문이라고 부르기도 한다)

```js
function showMessage() {
  alert( '안녕하세요!' );
}
```

`function` 키워드, *함수 이름*, 괄호로 둘러싼 매개변수를 차례로 써주면 함수를 선언할 수 있다. 위 함수에는 매개변수가 없는데, 만약 매개변수가 여러 개 있다면 각 매개변수를 콤마로 구분해준다. 이어서 함수를 구성하는 코드의 모임인 '함수 본문(body)'을 중괄호로 감싸 준다.

```js
function name(parameters) {
  ...함수 본문...
}
```

새롭게 정의한 함수는 함수 이름 옆에 괄호를 붙여 호출할 수 있다. `showMessage()`같이 할 수 있다.

```js
function showMessage() {
  alert( '안녕하세요!' );
}

showMessage();
showMessage();
```

`showMessage()`로 함수를 호출하면 함수 본문이 실행된다. 위 예시에선 showMessage를 두 번 호출했으므로 얼럿 창이 두 번 뜨게 된다.

함수의 주요 용도 중 하나는 중복 코드 피하기다.

얼럿 창에 보여줄 메시지를 바꾸거나 메시지를 보여주는 방식 자체를 변경하고 싶다면, 함수 본문 중 출력에 관여하는 코드 딱 하나만 수정해주면 된다.

## 지역 변수

함수 내에서 선언한 변수인 지역 변수(local variable)는 함수 안에서만 접근할 수 있다.

```js
function showMessage() {
  let message = "안녕하세요!"; // 지역 변수

  alert( message );
}

showMessage(); // 안녕하세요!

alert( message ); // ReferenceError: message is not defined (message는 함수 내 지역 변수이기 때문에 에러가 발생합니다.)
```

## 외부 변수

함수 내부에서 함수 외부의 변수인 외부 변수(outer variable)에 접근할 수 있다.

```js
let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
```

함수에선 외부 변수에 접근하는 것뿐만 아니라, 수정도 할 수 있다.

```js
let userName = 'John';

function showMessage() {
  userName = "Bob"; // (1) 외부 변수를 수정함

  let message = 'Hello, ' + userName;
  alert(message);
}

alert( userName ); // 함수 호출 전이므로 John 이 출력됨

showMessage();

alert( userName ); // 함수에 의해 Bob 으로 값이 바뀜
```

외부 변수는 지역 변수가 없는 경우에만 사용할 수 있다.

함수 내부에 외부 변수와 동일한 이름을 가진 변수가 선언되었다면, 내부 변수는 외부 변수를 *가리킨다*. 함수 내부에 외부 변수와 동일한 이름을 가진 지역 변수 `userName`가 선언되어 있다. 외부 변수는 내부 변수에 가려져 값이 수정되지 않았다.

```js
let userName = 'John';

function showMessage() {
  let userName = "Bob"; // 같은 이름을 가진 지역 변수를 선언한다.

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// 함수는 내부 변수인 userName만 사용한다,
showMessage();

alert( userName ); // 함수는 외부 변수에 접근하지 않는다. 따라서 값이 변경되지 않고, John이 출력된다.
```

**전역 변수**

위 예시의 `userName`처럼, 함수 외부에 선언된 변수는 *전역 변수(global variable)* 라고 부른다.

전역 변수는 같은 이름을 가진 지역 변수에 의해 가려지지만 않는다면 모든 함수에서 접근할 수 있다.

**변수는 연관되는 함수 내에 선언하고, `전역 변수는 되도록 사용하지 않는 것이 좋다.`** 비교적 근래에 작성된 코드들은 대부분 전역변수를 사용하지 않거나 최소한으로만 사용한다. 다만 프로젝트 전반에서 사용되는 데이터는 전역 변수에 저장하는 것이 유용한 경우도 있으니 이 점을 기억하자.

## 매개변수

매개변수(parameter)를 이용하면 임의의 데이터를 함수 안에 전달할 수 있다. 매개변수는 *인수(argument)* 라고 불리기도 한다.

**-> 함수를 정의할 때 사용하는 경우 : Parameter / 함수를 호출할 때 사용하는 경우 : Argument**

아래 예시에서 함수 showMessage는 매개변수 `from` 과 `text`를 가진다.

```js
function showMessage(from, text) { // 인수: from, text
  alert(from + ': ' + text);
}

showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', "What's up?"); // Ann: What's up? (**)
```

`(*)`, `(**)`로 표시한 줄에서 함수를 호출하면, 함수에 전달된 인자는 지역변수 `from`과 `text`에 복사된다. 그 후 함수는 지역변수에 복사된 값을 사용한다.

전역 변수 `from`이 있고, 이 변수를 함수에 전달하였다. 함수가 `from`을 변경하지만, 변경 사항은 외부 변수 `from`에 반영되지 않았다. 함수는 언제나 복사된 값을 사용하기 때문이다.

```js
function showMessage(from, text) {

  from = '*' + from + '*'; // "from"을 좀 더 멋지게 꾸며준다.

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// 함수는 복사된 값을 사용하기 때문에 바깥의 "from"은 값이 변경되지 않는다.
alert( from ); // Ann
```

## 기본값

매개변수에 값을 전달하지 않으면 그 값은 `undefined`가 된다.

위에서 정의한 함수 `showMessage(from, text)`는 매개변수가 2개지만, 아래와 같이 인수를 하나만 넣어서 호출할 수 있다.

```js
showMessage("Ann");
```

이렇게 코드를 작성해도 에러가 발생하지 않는다. 두 번째 매개변수에 값을 전달하지 않았기 때문에 `text`엔 `undefiend`가 할당될 뿐이다. 따라서 에러 없이 `"Ann: undefined"`가 출력된다.

매개변수에 값을 전달하지 않아도 그 값이 `undefined`가 되지 않게 하려면 '기본값(default value)'을 설정해주면 된다. 매개변수 오른쪽에 `=`을 붙이고 `undefined` 대신 설정하고자 하는 기본값을 써주면 된다.

```js
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

이젠 `text`가 값을 전달받지 못해도 `undefined`대신 기본값 `"no text given"`이 할당된다.

위 예시에선 문자열 `"no text given"`을 기본값으로 설정했다. 하지만 아래와 같이 복잡한 표현식도 기본값으로 설정할 수도 있다.

```js
function showMessage(from, text = anotherFunction()) {
  // anotherFunction()은 text값이 없을 때만 호출됨
  // anotherFunction()의 반환 값이 text의 값이 됨
}
```

**매개변수 기본값 평가 시점**

자바스크립트에선 함수를 호출할 때마다 매개변수 기본값을 평가한다. 물론 해당하는 매개변수가 없을 때만 기본값을 평가한다.

위 예시에선 매개변수 `text`에 값이 없는 경우 `showMessage()`를 호출할 때마다 `anotherFunction()`이 호출된다.

### 매개변수 기본값을 설정할 수 있는 또 다른 방법

가끔은 함수 선언부에서 매개변수 기본값을 설정하는 것 대신 함수가 실행되는 도중에 기본값을 설정하는 게 논리에 맞는 경우가 생기기도 한다.

이런 경우엔 일단 매개변수를 `undefined`와 비교하여 함수 호출 시 매개변수가 생략되었는지를 확인한다.

```js
function showMessage(text) {
  if (text === undefined) {
    text = '빈 문자열';
  }

  alert(text);
}

showMessage(); // 빈 문자열
```

이렇게 `if`문을 쓰는 것 대신 논리 연산자 `||`를 사용할 수도 있다.

```js
// 매개변수가 생략되었거나 빈 문자열("")이 넘어오면 변수에 '빈 문자열'이 할당된다.
function showMessage(text) {
  text = text || '빈 문자열';
  ...
}
```

이 외에도 모던 자바스크립트 엔진이 지원하는 [null 병합 연산자(nullish coalescing operator)](https://ko.javascript.info/nullish-coalescing-operator) `??`를 사용하면 `0`처럼 falsy로 평가되는 값들을 일반 값처럼 처리할 수 있어서 좋다.

```js
// 매개변수 'count'가 넘어오지 않으면 'unknown'을 출력해주는 함수
function showCount(count) {
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
showCount(undefined); // unknown
```

## [반환 값](https://ko.javascript.info/function-basics#ref-571)

함수를 호출했을 때 함수를 호출한 그곳에 특정 값을 반환하게 할 수 있다. 이때 이 특정 값을 반환 값(return value)이라고 부른다.

```js
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

지시자 `return`은 함수 내 어디서든 사용할 수 있다. 실행 흐름이 지시자 `return`을 만나면 함수 실행은 즉시 중단되고 함수를 호출한 곳에 값을 반환한다. 위 예시에선 반환 값을 `result`에 할당하였다.

아래와 같이 함수 하나에 여러 개의 `return`문이 올 수도 있다.

```js
function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('보호자의 동의를 받으셨나요?');
  }
}

let age = prompt('나이를 알려주세요', 18);

if ( checkAge(age) ) {
  alert( '접속 허용' );
} else {
  alert( '접속 차단' );
}
```

아래와 같이 지시자 `return`만 명시하는 것도 가능합니다. 이런 경우는 함수가 즉시 종료된다.

```js
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "영화 상영" ); // (*)
  // ...
}
```

위 예시에서, `checkAge(age)`가 `false`를 반환하면, `(*)`로 표시한 줄은 실행이 안 되기 때문에 함수 `showMovie`는 얼럿 창을 보여주지 않는다.

**`return`문이 없거나 `return` 지시자만 있는 함수는 `undefined`를 반환한다.**

`return`문이 없는 함수도 무언가를 반환합니다. `undefined`를 반환한다.

```js
function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
```

`return` 지시자만 있는 경우도 `undefined`를 반환합니다. `return`은 `return undefined`와 동일하게 동작하죠.

```js
function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
```

**`return`과 값 사이에 절대 줄을 삽입하지 마세요.**

반환하려는 값이 긴 표현식인 경우, 아래와 같이 지시자 `return`과 반환하려는 값 사이에 새 줄을 넣어 코드를 작성하고 싶을 수도 있습니다.

```js
return
 (some + long + expression + or + whatever * f(a) + f(b))
```

자바스크립트는 return문 끝에 세미콜론을 자동으로 넣기 때문에 이렇게 `return`문을 작성하면 안 됩니다. 위 코드는 아래 코드처럼 동작합니다.

```js
return;
 (some + long + expression + or + whatever * f(a) + f(b))
```

따라서 반환하고자 했던 표현식을 반환하지 못하고 아무것도 반환하지 않는 것처럼 되어버립니다.

표현식을 여러 줄에 걸쳐 작성하고 싶다면 표현식이 `return` 지시자가 있는 줄에서 시작하도록 작성해야 합니다. 또는 아래와 같이 여는 괄호를 `return` 지시자와 같은 줄에 써줘도 괜찮습니다.

```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```

이렇게 하면 의도한 대로 표현식을 반환할 수 있습니다.

## [함수 이름짓기](https://ko.javascript.info/function-basics#function-naming)

함수는 어떤 `동작`을 수행하기 위한 코드를 모아놓은 것이다. 따라서 함수의 이름은 대개 동사이다. 함수 이름은 가능한 한 간결하고 명확해야 한다. 함수가 어떤 동작을 하는지 설명할 수 있어야 하죠. 코드를 읽는 사람은 함수 이름만 보고도 함수가 어떤 기능을 하는지 힌트를 얻을 수 있어야 한다.

함수가 어떤 동작을 하는지 축약해서 설명해주는 동사를 접두어로 붙여 함수 이름을 만드는 게 관습입니다. 다만, 팀 내에서 그 뜻이 반드시 합의된 접두어만 사용해야 한다.

`"show"`로 시작하는 함수는 대개 무언가를 보여주는 함수다.

이 외에 아래와 같은 접두어를 사용할 수 있다.

- `"get…"` – 값을 반환함
- `"calc…"` – 무언가를 계산함
- `"create…"` – 무언가를 생성함
- `"check…"` – 무언가를 확인하고 불린값을 반환함

위 접두어를 사용하면 아래와 같은 함수를 만들 수 있다.

```js
showMessage(..)     // 메시지를 보여줌
getAge(..)          // 나이를 나타내는 값을 얻고 그 값을 반환함
calcSum(..)         // 합계를 계산하고 그 결과를 반환함
createForm(..)      // form을 생성하고 만들어진 form을 반환함
checkPermission(..) // 승인 여부를 확인하고 true나 false를 반환함
```

접두어를 적절히 활용하면 함수 이름만 보고도 함수가 어떤 동작을 하고 어떤 값을 반환하는지 쉽게 알 수 있다.

**함수는 동작 하나만 담당해야 한다.**

함수는 함수 이름에 언급되어있는 동작을 정확히 수행해야 한다. 그 이외의 동작은 수행해선 안 된다.

독립적인 두 개의 동작은 독립된 함수 두 개에서 나눠서 수행할 수 있게 해야 한다. 한 장소에서 두 동작을 동시에 필요로 하는 경우라도 말이다(이 경우는 제3의 함수를 만들어 그곳에서 두 함수를 호출한다).

> 개발자들이 빈번히 하는 실수들.
>
> 1.`getAge` 함수는 나이를 얻어오는 동작만 수행해야 한다. `alert` 창에 나이를 출력해주는 동작은 이 함수에 들어가지 않는 것이 좋다.
>
> 2.`createForm` 함수는 form을 만들고 이를 반환하는 동작만 해야 한다. form을 문서에 추가하는 동작이 해당 함수에 들어가 있으면 좋지 않다.
>
> 3.`checkPermission` 함수는 승인 여부를 확인하고 그 결과를 반환하는 동작만 해야 한다. 승인 여부를 보여주는 메시지를 띄우는 동작이 들어가 있으면 좋지 않다.

위 예시들은 접두어의 의미가 합의되었다고 가정하고 만들었다. 본인이나 본인이 속한 팀에서 접두어의 의미를 재합의하여 함수를 만들 수도 있긴 하지만, 아마도 위 예시에서 사용한 접두어 의미와 크게 차이가 나진 않을 거다. 어찌 되었든 접두어를 사용하여 함수 이름을 지을 땐, 해당 접두어에 어떤 의미가 있는지 잘 이해하고 있어야 한다. 해당 접두어가 붙은 함수가 어떤 동작을 하는지, 어떤 동작은 하지 못하는지 알고 있어야 한다. 접두어를 붙여 만든 모두 함수는 팀에서 만든 규칙을 반드시 따라야 한다. 팀원들은 이 규칙을 충분히 이해하고 있어야 하며, 팀원들 사이에 이 규칙이 잘 공유되어야 한다.

**아주 짧은 이름**

정말 *빈번히* 쓰이는 함수 중에 이름이 아주 짧은 함수가 있다.

[jQuery](http://jquery.com/) 프레임워크에서 쓰이는 함수 `$`와 [Lodash](http://lodash.com/) 라이브러리의 핵심 함수 `_` 말이다.

이 함수들은 지금까지 소개한 함수 이름짓기에 관련된 규칙을 지키지 않고 있다. 예외에 속하죠. 함수 이름은 간결하고 함수가 어떤 일을 하는지 설명할 수 있게 지어야한다.

## 함수 == 주석

함수는 간결하고, 한 가지 기능만 수행할 수 있게 만들어야 한다. 함수가 길어지면 함수를 잘게 쪼갤 때가 되었다는 신호로 받아들이셔야 한다. 함수를 쪼개는 건 쉬운 작업은 아니다. 하지만 함수를 분리해 작성하면 많은 장점이 있기 때문에 함수가 길어질 경우엔 함수를 분리해 작성할 것을 권유한다.

함수를 간결하게 만들면 테스트와 디버깅이 쉬워지고, 함수 그 자체로 주석의 역할까지 한다!

같은 동작을 하는 함수, `showPrimes(n)`를 두 개 만들어 비교해 보자. `showPrimes(n)`은 `n`까지의 [소수(prime numbers)](https://en.wikipedia.org/wiki/Prime_number)를 출력해준다.

첫 번째 `showPrimes(n)`에선 레이블을 사용해 반복문을 작성해본다.

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // 소수
  }
}
```

두 번째 `showPrimes(n)`는 소수인지 아닌지 여부를 검증하는 코드를 따로 분리해 `isPrime(n)`이라는 함수에 넣어서 작성했다.

```js
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

두 번째 `showPrimes(n)`가 더 이해하기 쉽다. `isPrime` 함수 이름을 보고 해당 함수가 소수 여부를 검증하는 동작을 한다는 걸 쉽게 알 수 있다. 이렇게 이름만 보고도 어떤 동작을 하는지 알 수 있는 코드를 *자기 설명적(self-describing)* 코드라고 부른다.

위와 같이 함수는 중복을 없애려는 용도 외에도 사용할 수 있다. 이렇게 함수를 활용하면 코드가 정돈되고 가독성이 높아진다.

## [요약](https://ko.javascript.info/function-basics#ref-573)

> **함수 선언 방식으로 함수를 만들 수 있다**
>
> > ```js
> > function 함수이름(복수의, 매개변수는, 콤마로, 구분한다) {
> >   /* 함수 본문 */
> > }
> > ```
>
> 1.함수에 전달된 매개변수는 복사된 후 함수의 지역변수가 된다.
>
> 2.함수는 외부 변수에 접근할 수 있다. 하지만 함수 바깥에서 함수 내부의 지역변수에 접근하는 건 불가능하다.
>
> 3.함수는 값을 반환할 수 있다. 값을 반환하지 않는 경우는 반환 값이 `undefined`가 된다.
>
> 4.깔끔하고 이해하기 쉬운 코드를 작성하려면 함수 내부에서 외부 변수를 사용하는 방법 대신 지역 변수와 매개변수를 활용하는 게 좋다.
>
> 5.개발자는 매개변수를 받아서 그 변수를 가지고 반환 값을 만들어 내는 함수를 더 쉽게 이해할 수 있다. 매개변수 없이 함수 내부에서 외부 변수를 수정해 반환 값을 만들어 내는 함수는 쉽게 이해하기 힘들다.

> **함수 이름을 지을 땐 아래와 같은 규칙을 따르는 것이 좋다.**
>
> 1.함수 이름은 함수가 어떤 동작을 하는지 설명할 수 있어야 한다. 이렇게 이름을 지으면 함수 호출 코드만 보아도 해당 함수가 무엇을 하고 어떤 값을 반환할지 바로 알 수 있다.
>
> 2.함수는 동작을 수행하기 때문에 이름이 주로 동사이다.
>
> 3.`create…`, `show…`, `get…`, `check…` 등의 잘 알려진 접두어를 사용해 이름을 지을 수 있다. 접두어를 사용하면 함수 이름만 보고도 해당 함수가 어떤 동작을 하는지 파악할 수 있다.

#### 2.16 함수 표현식

##### 함수 표현식

자바스크립트는 함수를 특별한 종류의 값으로 취급한다. 다른 언어에서처럼 "특별한 동작을 하는 구조"로 취급되지 않는다.

이전 챕터에서 아래와 같은 *함수 선언(Function Declaration) 방식으로 함수를 만들었었다.

```js
function sayHi() {
  alert( "Hello" );
}
```

함수 선언 방식 외에 *함수 표현식(Function Expression)* 을 사용해서 함수를 만들 수 있다.

```js
let sayHi = function() {
  alert( "Hello" );
};
```

함수를 생성하고 변수에 값을 할당하는 것처럼 함수가 변수에 할당되었다. 함수가 어떤 방식으로 만들어졌는지에 관계없이 함수는 값이고, 따라서 변수에 할당할 수 있다. 위 예시에선 함수가 변수 `sayHi`에 저장된 값이 되었다.

위 예시를 간단한 말로 풀면 다음과 같다: “함수를 만들고 그 함수를 변수 `sayHi`에 할당하기”

함수는 값이기 때문에 `alert`를 이용하여 함수 코드를 출력할 수도 있다.

```js
function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // 함수 코드가 보임
```

마지막 줄에서 `sayHi`옆에 괄호가 없기 때문에 함수는 실행되지 않는다. 어떤 언어에선 괄호 없이 함수 이름만 언급해도 함수가 실행된다. 하지만 자바스크립트는 괄호가 있어야만 함수가 호출된다.

자바스크립트에서 함수는 값이다. 따라서 함수를 값처럼 취급할 수 있다. 위 코드에선 함수 소스 코드가 문자형으로 바뀌어 출력되었다.

함수는 `sayHi()`처럼 호출할 수 있다는 점 때문에 일반적인 값과는 조금 다르다. 특별한 종류의 값이다.

하지만 그 본질은 값이기 때문에 값에 할 수 있는 일을 함수에도 할 수 있다. 변수를 복사해 다른 변수에 할당하는 것처럼 함수를 복사해 다른 변수에 할당할 수도 있다.

```js
function sayHi() {   // (1) 함수 생성
  alert( "Hello" );
}

let func = sayHi;    // (2) 함수 복사

func(); // Hello     // (3) 복사한 함수를 실행(정상적으로 실행된다)!
sayHi(); // Hello    //     본래 함수도 정상적으로 실행된다.
```

1. `(1)`에서 함수 선언 방식을 이용해 함수를 생성한다. 생성한 함수는 `sayHi`라는 변수에 저장된다.
2. `(2)` 에선 `sayHi`를 새로운 변수 `func`에 복사한다. 이때 `sayHi` 다음에 괄호가 없다는 점에 유의해야한다. 괄호가 있었다면 `func = sayHi()` 가 되어 `sayHi` *함수* 그 자체가 아니라, *함수 호출 결과(함수의 반환 값)* 가 `func`에 저장되었을 거다.
3. 이젠 `sayHi()` 와 `func()`로 함수를 호출할 수 있게 되었다.

함수 `sayHi`는 아래와 같이 함수 표현식을 사용해 정의할 수 있다.

```js
let sayHi = function() {
  alert( "Hello" );
};

let func = sayHi;
// ...
```

동작 결과는 동일하다.

**끝에 세미 콜론은 왜 있나요?**

함수 표현식의 끝에 왜 세미 콜론 `;`이 붙는지 의문이 들 수 있다. 함수 선언문에는 세미 콜론이 없는데 말이다.

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
```

- `if { ... }`, `for { }`, `function f { }` 같이 중괄호로 만든 코드 블록 끝엔 `;`이 없어도 된다.
- 함수 표현식은 `let sayHi = ...;`과 같은 구문 안에서 값의 역할을 한다. 코드 블록이 아니고 값처럼 취급되어 변수에 할당된다. 모든 구문의 끝엔 세미 콜론 `;`을 붙이는 게 좋다. 함수 표현식에 쓰인 세미 콜론은 함수 표현식 때문에 붙여진 게 아니라, 구문의 끝이기 때문에 붙여졌다.

## 콜백 함수

매개변수가 3개 있는 함수, `ask(question, yes, no)`를 작성해보면, 각 매개변수에 대한 설명은 아래와 같다.

- `question`

  질문

- `yes`

  "Yes"라고 답한 경우 실행되는 함수

- `no`

  "No"라고 답한 경우 실행되는 함수

함수는 반드시 `question(질문)`을 해야 하고, 사용자의 답변에 따라 `yes()` 나 `no()`를 호출한다.

```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "동의하셨습니다." );
}

function showCancel() {
  alert( "취소 버튼을 누르셨습니다." );
}

// 사용법: 함수 showOk와 showCancel가 ask 함수의 인수로 전달됨
ask("동의하십니까?", showOk, showCancel);
```

이렇게 함수를 작성하는 방법은 실무에서 아주 유용하게 쓰인다. 면대면으로 질문하는 것보다 위처럼 컨펌창을 띄워 질문을 던지고 답변을 받으면 간단하게 설문조사를 진행할 수 있다. 실제 상용 서비스에선 컨펌 창을 좀 더 멋지게 꾸미는 등의 작업이 동반되긴 하지만, 일단 여기선 그게 중요한 포인트는 아니다.

**함수 `ask`의 인수, `showOk`와 `showCancel`은 \*콜백 함수\* 또는 \*콜백\*이라고 불린다.**

함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 그 함수를 "나중에 호출(called back)"하는 것이 콜백 함수의 개념이다. 위 예시에선 사용자가 "yes"라고 대답한 경우 `showOk`가 콜백이 되고, "no"라고 대답한 경우 `showCancel`가 콜백이 된다.

아래와 같이 함수 표현식을 사용하면 코드 길이가 짧아진다.

```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);
```

`ask(...)` 안에 함수가 선언된 게 보이시나요? 이렇게 이름 없이 선언한 함수는 *익명 함수(anonymous function)* 라고 부른다. 익명 함수는 (변수에 할당된 게 아니기 때문에) `ask` 바깥에선 접근할 수 없다. 위 예시는 의도를 가지고 이렇게 구현하였기 때문에 바깥에서 접근할 수 없어도 문제가 없다.

자바스크립트를 사용하다 보면 콜백을 활용한 코드를 아주 자연스레 만나게 됩니다. 이런 코드는 자바스크립트의 정신을 대변한다.

**함수는 "동작"을 나타내는 값이다.**

문자열이나 숫자 등의 일반적인 값들은 *데이터*를 나타내지만,함수는 하나의 *동작(action)*을 나타낸다. 동작을 대변하는 값인 함수를 변수 간 전달하고, 동작이 필요할 때 이 값을 실행할 수 있다.

## 함수 표현식 vs 함수 선언문

**함수 표현식과 선언문의 차이**

첫 번째는 문법이다.

- *함수 선언문:* 함수는 주요 코드 흐름 중간에 독자적인 구문 형태로 존재한다.

  ```js
  // 함수 선언문
  function sum(a, b) {
    return a + b;
  }
  ```

- *함수 표현식:* 함수는 표현식이나 구문 구성(syntax construct) 내부에 생성된다. 아래 예시에선 함수가 할당 연산자 `=`를 이용해 만든 “할당 표현식” 우측에 생성되었다.

  ```js
  // 함수 표현식
  let sum = function(a, b) {
    return a + b;
  };
  ```

두 번째 차이는 자바스크립트 엔진이 *언제* 함수를 생성하는지에 있다.

**함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있다.**

스크립트가 실행되고, 실행 흐름이 `let sum = function…`의 우측(함수 표현식)에 도달 했을때 함수가 생성된다. 이때 이후부터 해당 함수를 사용(할당, 호출 등)할 수 있다.

하지만 함수 선언문은 조금 다른데, **함수 선언문은 함수 선언문이 정의되기 전에도 호출할 수 있습니다.** 따라서 전역 함수 선언문은 스크립트 어디에 있느냐에 상관없이 어디에서든 사용할 수 있다.

이게 가능한 이유는 자바스크립트의 내부 알고리즘 때문이다. 자바스크립트는 스크립트를 실행하기 전, 준비단계에서 전역에 선언된 함수 선언문을 찾고, 해당 함수를 생성한다. 스크립트가 진짜 실행되기 전 "초기화 단계"에서 함수 선언 방식으로 정의한 함수가 생성되는 것이다. 스크립트는 함수 선언문이 모두 처리된 이후에서야 실행된다. 따라서 스크립트 어디서든 함수 선언문으로 선언한 함수에 접근할 수 있는 것이다.

```js
sayHi("John"); // Hello, John

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

함수 선언문, `sayHi`는 스크립트 실행 준비 단계에서 생성되기 때문에, 스크립트 내 어디에서든 접근할 수 있다.

그러나 함수 표현식으로 정의한 함수는 함수가 선언되기 전에 접근하는 게 불가능하다.

```js
sayHi("John"); // error!

let sayHi = function(name) {  // (*) 마술은 일어나지 않는다.
  alert( `Hello, ${name}` );
};
```

함수 표현식은 실행 흐름이 표현식에 다다랐을 때 만들어진다. 위 예시에선 `(*)`로 표시한 줄에 실행 흐름이 도달했을 때 함수가 만들어진다. 아주 늦다.

세 번째 차이점은, 스코프다. **엄격 모드에서 함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다. 하지만 블록 밖에서는 함수에 접근하지 못한다.**

런타임에 그 값을 알 수 있는 변수 `age`가 있고, 이 변수의 값에 따라 함수 `welcome()`을 다르게 정의해야 하는 상황이다. 그리고 함수 `welcome()`은 나중에 사용해야 하는 상황이라고 가정해 보자.

함수 선언문을 사용하면 의도한 대로 코드가 동작하지 않는다.

```js
let age = prompt("나이를 알려주세요.", 18);

// 조건에 따라 함수를 선언함
if (age < 18) {

  function welcome() {
    alert("안녕!");
  }

} else {

  function welcome() {
    alert("안녕하세요!");
  }

}

// 함수를 나중에 호출한다.
welcome(); // Error: welcome is not defined
```

함수 선언문은 함수가 선언된 코드 블록 안에서만 유효하기 때문에 이런 에러가 발생한다.

또 다른 예시를 살펴보자.

```js
let age = 16; // 16을 저장했다 가정하자.

if (age < 18) {
  welcome();               // \   (실행)
                           //  |
  function welcome() {     //  |
    alert("안녕!");        //  |  함수 선언문은 함수가 선언된 블록 내
  }                        //  |  어디에서든 유효하다
                           //  |
  welcome();               // /   (실행)

} else {

  function welcome() {
    alert("안녕하세요!");
  }
}

// 여기는 중괄호 밖이기 때문에
// 중괄호 안에서 선언한 함수 선언문은 호출할 수 없다.

welcome(); // Error: welcome is not defined
```

그럼 `if`문 밖에서 `welcome` 함수를 호출할 방법은 없는 걸까? 함수 표현식을 사용하면 가능하다. `if`문 밖에 선언한 변수 `welcome`에 함수 표현식으로 만든 함수를 할당하면 된다

이제 코드가 의도한 대로 동작한다.

```js
let age = prompt("나이를 알려주세요.", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("안녕!");
  };

} else {

  welcome = function() {
    alert("안녕하세요!");
  };

}

welcome(); // 제대로 동작한다.
```

물음표 연산자 `?`를 사용하면 위 코드를 좀 더 단순화할 수 있다.

```js
let age = prompt("나이를 알려주세요.", 18);

let welcome = (age < 18) ?
  function() { alert("안녕!"); } :
  function() { alert("안녕하세요!"); };

welcome(); // 제대로 동작합니다.
```

**함수 선언문과 함수 표현식 중 무엇을 선택해야 하나요?**

함수 선언문을 이용해 함수를 선언하는 걸 먼저 고려하는 게 좋다. 함수 선언문으로 함수를 정의하면, 함수가 선언되기 전에 호출할 수 있어서 코드 구성을 좀 더 자유롭게 할 수 있다.

함수 선언문을 사용하면 가독성도 좋아진다. 코드에서 `let f = function(…) {…}`보다 `function f(…) {…}` 을 찾는 게 더 쉽기 때문이다. 함수 선언 방식이 더 “눈길을 사로잡는다”. 그러나 어떤 이유로 함수 선언 방식이 적합하지 않거나, (위 예제와 같이) 조건에 따라 함수를 선언해야 한다면 함수 표현식을 사용해야 한다.

## 

> ### 요약
>
> - 함수는 값이다. 따라서 함수도 값처럼 할당, 복사, 선언할 수 있다.
> - “함수 선언(문)” 방식으로 함수를 생성하면, 함수가 독립된 구문 형태로 존재하게 된다.
> - “함수 표현식” 방식으로 함수를 생성하면, 함수가 표현식의 일부로 존재하게 된다.
> - 함수 선언문은 코드 블록이 실행되기도 전에 처리됩니다. 따라서 블록 내 어디서든 활용 가능하다.
> - 함수 표현식은 실행 흐름이 표현식에 다다랐을 때 만들어진다.
>
> **함수를 선언해야 한다면 함수가 선언되기 이전에도 함수를 활용할 수 있기 때문에, 함수 선언문 방식을 따르는 게 좋다. 함수 선언 방식은 코드를 유연하게 구성할 수 있도록 해주고, 가독성도 좋다. 마지막으로 함수 표현식은 함수 선언문을 사용하는게 부적절할 때에 사용하는 것이 좋다.**

## 2.17 화살표 함수 기본

함수 표현식보다 단순하고 간결한 문법으로 함수를 만들 수 있는 방법이 있다.

바로 화살표 함수(arrow function)를 사용하는 것이다. 화살표 함수라는 이름은 문법의 생김새를 차용해 지어졌다고 한다.

```js
let func = (arg1, arg2, ...argN) => expression
```

이렇게 코드를 작성하면 인자 `arg1..argN`를 받는 함수 `func`이 만들어진다. 함수 `func`는 화살표(`=>`) 우측의 `표현식(expression)`을 평가하고, 평가 결과를 반환한다.

아래 함수의 축약 버전이라고 할 수 있다.

```js
let func = function(arg1, arg2, ...argN) {
  return expression;
};
```

좀 더 구체적인 예시를 살펴보자.

```js
let sum = (a, b) => a + b;

/* 위 화살표 함수는 아래 함수의 축약 버전이다.

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
```

보시는 바와 같이 `(a, b) => a + b`는 인수 `a`와 `b`를 받는 함수다. `(a, b) => a + b`는 실행되는 순간 표현식 `a + b`를 평가하고 그 결과를 반환한다.

- 인수가 하나밖에 없다면 인수를 감싸는 괄호를 생략할 수 있다. 괄호를 생략하면 코드 길이를 더 줄일 수 있다.

  예시:

  ```js
  let double = n => n * 2;
  // let double = function(n) { return n * 2 }과 거의 동일하다.
  
  alert( double(3) ); // 6
  ```

- 인수가 하나도 없을 땐 괄호를 비워놓으면 된다. 다만, 이 때 괄호는 생략할 수 없다.

  ```js
  let sayHi = () => alert("안녕하세요!");
  
  sayHi();
  ```

화살표 함수는 함수 표현식과 같은 방법으로 사용할 수 있다.

아래 예시와 같이 함수를 동적으로 만들 수 있다.

```js
let age = prompt("나이를 알려주세요.", 18);

let welcome = (age < 18) ?
  () => alert('안녕') :
  () => alert("안녕하세요!");

welcome();
```

화살표 함수를 처음 접하면 가독성이 떨어진다. 익숙지 않기 때문이다. 하지만 문법이 눈에 익기 시작하면 적응은 식은 죽 먹기가 된다.

함수 본문이 한 줄인 간단한 함수는 화살표 함수를 사용해서 만드는 게 편리하다. 타이핑을 적게 해도 함수를 만들 수 있다는 장점이 있다.

## 본문이 여러 줄인 화살표 함수

위에서 소개해 드린 화살표 함수들은 `=>` 왼쪽에 있는 인수를 이용해 `=>` 오른쪽에 있는 표현식을 평가하는 함수들이다.

그런데 평가해야 할 표현식이나 구문이 여러 개인 함수가 있을 수도 있다. 이 경우 역시 화살표 함수 문법을 사용해 함수를 만들 수 있다. 다만, 이때는 중괄호 안에 평가해야 할 코드를 넣어주어야 한다. 그리고 `return` 지시자를 사용해 명시적으로 아래와 같이 결과값을 반환해 주어야 한다.

```js
let sum = (a, b) => {  // 중괄호는 본문 여러 줄로 구성되어 있음을 알려준다.
  let result = a + b;
  return result; // 중괄호를 사용했다면, return 지시자로 결괏값을 반환해주어야 한다.
};

alert( sum(1, 2) ); // 3
```



> ### 요약
>
> 화살표 함수는 본문이 한 줄인 함수를 작성할 때 유용하다. 본문이 한 줄이 아니라면 다른 방법으로 화살표 함수를 작성해야 한다.
>
> 1. 중괄호 없이 작성: `(...args) => expression` – 화살표 오른쪽에 표현식을 둔다. 함수는 이 표현식을 평가하고, 평가 결과를 반환한다.
> 2. 중괄호와 함께 작성: `(...args) => { body }` – 본문이 여러 줄로 구성되었다면 중괄호를 사용해야 한다. 다만, 이 경우는 반드시 `return` 지시자를 사용해 반환 값을 명기해 주어야 한다.

## 2.18 기본 문법 요약

## 코드 구조

여러 개의 구문은 세미콜론을 기준으로 구분할 수 있다.

```js
alert('Hello'); alert('World');
```

줄 바꿈도 여러 개의 구문을 구분하는 데 사용되므로 아래 코드는 정상적으로 동작한다.

```js
alert('Hello')
alert('World')
```

이런 동작 방식을 '세미콜론 자동 삽입(automatic semicolon insertion)'이라고 부른다. 그런데 세미콜론 자동 삽입이 동작하지 않을 때도 있다.

```js
alert("이 메시지가 출력된 후에 에러가 발생합니다.")

[1, 2].forEach(alert)
```

코딩 컨벤션과 같은 코드 스타일 지침서 대부분은 문장의 끝에 세미콜론을 붙이는 걸 권장한다.

코드 블록(`{...}` )이나 코드 블록과 함께 구성되는 문법(예: 반복문) 끝엔 세미콜론을 붙이지 않아도 괜찮다.

```js
function f() {
  // 함수 선언문 끝엔 세미콜론이 필요 없다.
}

for(;;) {
  // 반복문 끝엔 세미콜론이 필요 없다.
}
```

세미콜론이 없어도 되는 자리에 ‘여분의’ 세미콜론을 붙이더라도 해당 세미콜론은 무시되기 때문에 에러가 발생하지 않는다.

## 엄격 모드

모던 자바스크립트에서 지원하는 모든 기능을 활성화하려면 스크립트 맨 위에 `'use strict'`를 적어줘야 한다.

```js
'use strict';

...
```

`'use strict'`는 스크립트 최상단이나 함수 본문 최상단에 있어야 한다.

`'use strict'`가 없어도 코드는 정상적으로 동작한다. 다만, 모던한 방식이 아닌 옛날 방식으로 동작한다. '하위 호환성’을 지키면서 말이다. 될 수 있으면 모던한 방식을 사용하는 걸 추천한다.

참고로, 추후에 배우게 될 클래스와 같은 몇몇 모던 기능은 엄격 모드를 자동으로 활성화한다.

## 변수

변수는 아래와 같은 키워드를 이용해 선언할 수 있다.

- `let`
- `const` – 한 번 값을 할당하면 더는 값을 바꿀 수 없는 상수를 정의할 때 쓰인다.
- `var` – 과거에 쓰이던 키워드로 현재는 사용을 지양하고 있다.

변수 이름 명명 규칙은 다음과 같다.

- 숫자와 문자를 사용하되 첫 글자는 숫자가 될 수 없다.
- 특수기호는 `$`와 `_`만 사용할 수 있다.
- 비 라틴계 언어의 문자나 상형문자도 사용할 수 있지만 잘 쓰이진 않다.

자바스크립트는 동적 타이핑을 허용하기 때문에, 자료형을 바꿔가며 값을 할당할 수 있다.

```js
let x = 5;
x = "John";
```

자바스크립트는 여덟 가지 기본 자료형을 지원한다.

- 정수와 부동 소수점을 저장하는 데 쓰이는 `숫자형`
- 아주 큰 숫자를 저장할 수 있는 `BigInt형`
- 문자열을 저장하는 데 쓰이는 `문자형`
- 논리값 `true/false`을 저장하는 데 쓰이는 `불린형`
- ‘비어있음’, '존재하지 않음’을 나타내는 `null` 값만을 위한 독립 자료형 `null`
- 값이 할당되지 않은 상태를 나타내는 `undefined` 값만을 위한 독립 자료형 `undefined`
- 복잡한 자료구조를 저장하는 데 쓰이는 `객체형`과 고유한 식별자를 만들 때 사용되는 `심볼형`

`typeof` 연산자는 값의 자료형을 반환해준다. 그런데 두 가지 예외 사항이 있다.

```js
typeof null == "object" // 언어 자체의 오류
typeof function(){} == "function" // 함수는 특별하게 취급된다.
```

## 상호작용

호스트 환경이 브라우저인 경우, 다음과 같은 UI 함수를 이용해 사용자와 상호작용할 수 있다.

- [`prompt(question, [default\])`](https://developer.mozilla.org/ko/docs/Web/API/Window/prompt)

  프롬프트 창에 매개변수로 받은 `question`을 넣어 사용자에게 보여준다. ‘확인’ 버튼을 눌렀을 땐 사용자가 입력한 값을 반환해주고, ‘취소’ 버튼을 눌렀을 땐 `null`을 반환한다.

- [`confirm(question)`](https://developer.mozilla.org/ko/docs/Web/API/Window/confirm)

  컨펌 대화상자에 매개변수로 받은 `question`을 넣어 사용자에게 보여줍니다. 사용자가 ‘확인’ 버튼을 누르면 `true`를, 그 외의 경우는 `false`를 반환한다.

- [`alert(message)`](https://developer.mozilla.org/ko/docs/Web/API/Window/alert)

  `message`가 담긴 얼럿 창을 보여준다.

세 함수는 모두 *모달* 창을 띄워주는데, 모달 창이 닫히기 전까지 코드 실행이 중지된다. 사용자는 모달 창 외에 페이지에 있는 그 무엇과도 상호작용할 수 없다.

```js
let userName = prompt("이름을 알려주세요.", "영희");
let isTeaWanted = confirm("차 한 잔 드릴까요?");

alert( "방문객: " + userName ); // 영희
alert( "차 주문 여부: " + isTeaWanted ); // true
```

## 연산자

자바스크립트는 아래와 같은 다양한 연산자를 제공한다.

- 산술 연산자

  사칙 연산에 관련된 연산자 `* + - /`와 나머지 연산자 `%`, 거듭제곱 연산자 `**`가 대표적인 산술 연산자에 속한다.이항 덧셈 연산자 `+`는 피연산자 중 하나가 문자열일 때 나머지 하나를 문자형으로 바꾸고 두 문자열을 연결한다.`alert( '1' + 2 ); // '12', 문자열 alert( 1 + '2' ); // '12', 문자열`

- 할당 연산자

  `a = b` 형태의 할당 연산자와 `a *= 2` 형태의 복합 할당 연산자가 있다.

- 비트 연산자

  비트 연산자는 인수를 32비트 정수로 변환하여 이진 연산을 수행한다. 자세한 내용은 [docs](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)에서 볼 수 있다.

- 조건부 연산자

  조건부 연산자는 자바스크립트 연산자 중 유일하게 매개변수가 3개인 연산자다. `cond ? resultA : resultB`와 같은 형태로 사용하고, `cond`가 truthy면 `resultA`를, 아니면 `resultB`를 반환한다.

- 논리 연산자

  AND 연산자 `&&`와 OR 연산자 `||`은 단락 평가를 수행하고, 평가가 멈춘 시점의 값을 반환한다(꼭 `true`나 `false`일 필요는 없다). NOT 연산자 `!`는 피연산자의 자료형을 불린형으로 바꾼 후 그 역을 반환한다.

- null 병합 연산자

  null 병합 연산자 `??`는 피연산자 중 실제 값이 정의된 피연산자를 찾는 데 쓰인다. `a`가 `null`이나 `undefined`가 아니면 `a ?? b`의 평가 결과는 `a`이고, `a`가 `null`이나 `undefined`이면 `a ?? b`의 평가 결과는 `b`가 된다.

- 비교 연산자

  동등 연산자 `==`는 형이 다른 값끼리 비교할 때 피연산자의 자료형을 숫자형으로 바꾼 후 비교를 진행한다. `null`과 `undefined`는 자기끼리 비교할 땐 참을 반환하지만 다른 자료형과 비교할 땐 거짓을 반환한다.`alert( 0 == false ); // true alert( 0 == '' ); // true`기타 비교 연산자들 `< > <= >=` 역시 피연산자의 자료형을 숫자형으로 바꾼 후 비교를 진행한다.일치 연산자 `===`는 피연산자의 형을 변환하지 않는다. 형이 다르면 무조건 다르다고 평가한다. `null`과 `undefined`는 특별한 값이다. 두 값을 `==` 연산자로 비교하면 `true`를 반환하지만, 다른 값과 비교하면 무조건 `false`를 반환한다.크고 작음을 비교하는 연산자의 피연산자로 문자열이 들어오면 글자 단위로 크기 비교가 이뤄진다. 다른 타입의 값이 들어오면 숫자형으로 형 변환한 후 비교를 진행한다.

- 기타 연산자

  쉼표 연산자 등의 기타 연산자도 있다.

## 반복문

- while, do-while, for 문은 아래와 같이 작성할 수 있다.

  ```js
  // 1
  while (condition) {
    ...
  }
  
  // 2
  do {
    ...
  } while (condition);
  
  // 3
  for(let i = 0; i < 10; i++) {
    ...
  }
  ```

- `for(let...)` 안쪽에 선언한 변수는 오직 반복문 내에서만 사용할 수 있다. `let`을 생략하고 기존에 선언되어있는 변수를 사용하는 것도 가능하다.

- 지시자 `break`나 `continue`는 반복문 전체나 현재 실행 중인 반복을 빠져나가는 데 사용된다. 레이블은 중첩 반복문을 빠져나갈 때 사용한다.

## 'switch’문

'switch’문은 `if`문을 사용해 재작성할 수 있다. 'switch’문은 조건을 확인할 때 내부적으로 일치 연산자 `===`를 사용해 비교를 진행한다.

```js
let age = prompt('나이를 알려주세요.', 18);

switch (age) {
  case 18:
    alert("Won't work"); // prompt 함수는 항상 문자열을 반환하므로, 이 case문엔 절대 도달할 수 없다.
    break;

  case "18":
    alert("낭랑 18세이시군요!");
    break;

  default:
    alert("어떤 case문에도 해당하지 않습니다.");
}
```

## 함수

세 가지 방법으로 함수를 만들 수 있다.

1. 함수 선언문: 주요 코드 흐름을 차지하는 방식

   ```js
   function sum(a, b) {
     let result = a + b;
   
     return result;
   }
   ```

2. 함수 표현식: 표현식 형태로 선언된 함수

   ```js
   let sum = function(a, b) {
     let result = a + b;
   
     return result;
   };
   ```

3. 화살표 함수:

   ```js
   // 화살표(=>) 우측엔 표현식이 있음
   let sum = (a, b) => a + b;
   
   // 대괄호{ ... }를 사용하면 본문에 여러 줄의 코드를 작성할 수 있음. return문이 꼭 있어야 함.
   let sum = (a, b) => {
     // ...
     return a + b;
   }
   
   // 인수가 없는 경우
   let sayHi = () => alert("Hello");
   
   // 인수가 하나인 경우
   let double = n => n * 2;
   ```

- 함수는 지역 변수를 가질 수 있다. 지역 변수는 함수의 본문에 선언된 변수로, 함수 내부에서만 접근할 수 있다.
- 매개변수에 기본값을 설정할 수 있다. 문법은 다음과 같다. `function sum(a = 1, b = 2) {...}`
- 함수는 항상 무언가를 반환한다. `return`문이 없는 경우는 `undefined`를 반환한다.