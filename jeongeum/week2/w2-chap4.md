## 객체

자바스크립트에는 8가지의 자료형이 있음
원시형 : 하나의 데이터(문자열, 숫자 등)만 담을 수 있음 (8개의 자료형 중 7개나 이 형태임!)
객체형 : 다양한 데이터를 담을 수 있음
 - {중괄호}를 이용해 만듦
 - 키(key, 문자형):값(value, 모든 자료형) <- 프로퍼티, 중괄호 안에 여러개 넣을 수 있다.
 - {키(key):값(value), 키(key):값(value), 키(key):값(value), ...}
 - 객체 생성자 문법 -> let user = new Object();
 - 객체 리터럴(중괄호를 이용해 객체 선언) 문법 -> let user ={};

리터럴과 프로퍼티
   let user = {name: "james", age: 500};
 - {키:값}
 - 프로퍼티 키 = 프로퍼티 '이름' 또는 '식별자'
 - 프로퍼티는 추가, 삭제 가능
 - 점표기법을 이용하여 프로퍼티 값 읽기 가능 => user.name = james
 - 프로퍼티 값에는 모든 자료형이 올 수 있음
 - 프로퍼티 이름을 짓을 때 여러 단어를 사용하면 꼭!! 따옴표로 묶어주기
   abc market : true  (x) / "abc market" : true  (o)
 - 마지막 프로퍼티는 쉼표로도 끝날 수 있음!
   let fruits = { apple: "red", orange: "orange", lemon: "yellow", }

 - 상수 객체는 수정 가능!
   const user = {
       name: "apple"
   };
   user.name = "orange"  (o)
   
   const 는 user의 값만 고정! 그 내용은 고정하지 않음!

대괄호 표기법
 - 여러 단어를 조합해 프로퍼티키(이름/식별자)를 만들면 점 표기법  (x)
 - 대괄호 표기법은 키에 어떤 문자열이 있던지 상관없이 동작
 - 하지만!! 대괄호 안의 문자열은 꼭 따옴표로 묶어줘야함!!!

계산된 프로퍼티
 - 객체를 만들 때 객체 리터럴 안의 프로퍼티가 []로 둘러싸여있을 때 부름
 - 대괄호 표기법은 프로퍼티 이름(키/식별자)과 값의 제약을 없애줌
 - 점 표기법보다 강력함!!! 그러나 작성하기에는 번거로움

= 프로퍼티의 이름이 확정, 단순한 이름 -> 점표기법
= 사용하다가 복잡한 상황이 발생 -> 대괄호 표기법

단축 프로퍼티
 - name:name -> name
 - 프로퍼티의 이름과 값이 변수와 이름이 동일할 때 생략할 수 있음! (수업 때 많이 했던 부분! 반갑다!)

프로퍼티 이름의 제약사항
 - 변수 이름(키/식별자)에는 "for", "let", "return" 예약어 사용 금지!!!!
 - 근데 또 객체 프로퍼티에는 제약 없음 (아이고!)

"in" 연산자로 프로퍼티 존재 여부 확인하기
 - 존재하지 않는 프로퍼티에 접근 -> 에러 발생 x ->undefined 반환
 - 이 특징을 응용해 프로퍼티의 존재 여부 확인 가능
   let user = {};
   alert(user.happyman === undefined);
   창으로 true 값 보여줌 
   -> true는 프로퍼티가 존재하지 않음을 의미 (그럼 false여야 하는게 아닌가??? 존재하지 않는데!!)

 - in 왼쪽에는 반드시 프로퍼티 이름(키/식별자)가 와야함!
 - 프로퍼티 이름은 보통 따옴표러 감싼 문자열!
 - 감싸지 않으면 변수가 됨
   let user = {age: 500};
   let key = "age";
   alert ("key" in user);  (o)
   alert (key in user);  (x)

"for...in" 반복문
 - 객체의 모든 키를 순회 가능
 - for(;;)반복문과는 완전 다름!!!!
   for (key in object){} 각 프로퍼티 키를 이용하여 본문을 실행시킴!

객체 정렬 방식
 - 프로퍼티에도 순서가..?
 - 객체는 특별한 방식으로 정렬
   - 정수 프로퍼티는 자동으로 정렬 : 변형 없이 정수에서 왔다 갔다 할 수 있는 문자열 "44"는 정수, 문자열모두 변형이 없기에 정수 프로퍼티, "+55", "6.234"는 정수 프로퍼티 아님
   - 그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬
  let codes = {"49": "a", "40": "b", "28": "c" //.., "1": "z"}
  for (let code in codes) { alert(code) ;}   1, 28, 40, 49
 - 정수가 되지 않게 프로퍼티 이름을 짓는다면 입력한 순서대로 출력됨!




## 참조에 의한 객체 복사

객체와 원시 타입의 차이
 - 객체 : 참조에 의해 저장, 복사
 - 원시 : 문자열, 숫자, 불린값으로 값 그대로 저장, 할당, 복사

 - 변수에는 객체 그대로 저장되는 것이 아님
 - 객체가 저장되어있는 "메모리 주소"인 객체애 대한 "참조 값"이 저장 (??)
   let user = { name: "John" };
   let admin = user; // 참조값을 복사함

 - 객체에 접근하거나 조작할 땐 여러 변수를 사용 가능
   let user = { name: 'John' };
   let admin = user;
   admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경됨
   alert(user.name); // 'Pete'가 출력됨. 'user' 참조 값을 이용해 변경사항을 확인함

 - 객체 : 서랍장 / 변수 : 서랍장을 열 수 있는 열쇠
 - 서랍장은 하나, 서랍장을 열 수 잇는 열쇠는 2개
 - 그 중 하나를 사용해(admin) 서랍장을 열어 정돈,
 - 다른 열쇠를 사용해 서랍장을 열면 정돈된 내용 확인 가능 (아하!)

참조에 의한 비교
 - 객체 비교시 동등 연산자 ==와 일치 연산자 === 동일하게 동작
 - 비교 시 피연산자인 두객체가 동일한 객체일 경우 참(true)을 반환
 - >,<등 대소 배교나 aaa == 1 같은 원시값의 비교에서는 객체가 원시형으로 변환

객체 복사, 병합과 object.assign
 - 자바스크립트는 객체 복제 내장 메서드를 지원하지 않음
 - 객체를 복제해야 할 일은 거의 없음
 - 참조에 의한 복사로 해결 가능한 일이 대다수
 - 새로운 객체를 만들고, 객체의 프로퍼티들을 순회해 원시 수준까지 프로퍼티를 복사
   Object.assign(dest, [src1, src2, src3...])
   dest : 첫번째 인수, 목표로하는 객체
   src1, ..., srcN : 이어지는 인수, 복사하고자 하는 객체
   객체 src1, ..., srcN의 프로퍼티를 dest에 복사
   dest를 제외한 인수(객체)의 프로퍼티 전부가 첫번째 인수(객체, =dest)로 복사
   dest 반환

중첩 객체 복사 (깊은 복사)
 - 프로퍼티는 다른 객체에 대한 참조 값일 수도 있음




## 가비지 컬렉션

자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리 수행
 - 원시값, 객체, 함수 등 만들어지는 모든 것은 메모리 차지
 - 그렇다면 쓸모없어진 것들은 어떻게 처리?

가비지 컬렉션 기준
 - 도달 가능성이라는 개념을 사용해 메모리 관리 수행
 - 도달 가능성 : 어떻게든 접근하거나 사용할 수 있는 값, 도달 가능한 값은 메모리에서 삭제하지 않음

 - 태생부터 도달 가능한 값을 가짐 (명백한 이유 없이 삭제 불가)
   현재 함수의 지역 변수와 매개변수 (=root(루트))
   중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수 (=root(루트))
   전역 변수 (=root(루트))
   기타 등등
 - 루트가 참조하는 값 / 체이닝으로 루트에 참조할 수 있는 값 = 도달 가능한 값
 - 전역 변수에 객체 저장 / 이 객체의 프로퍼티가 다른 객체 참조 -> 프로퍼티가 참조하는 객체는 도달 가능한 값
 - 객체에 접근이 가능할 때는 메모리에서 삭제 되지않지만, null값으로 덮이면 메모리에서 삭제될 수 있음

연결된 객체

도달할 수 없는 섬

내부 알고리즘
 - "mark-and-sweep" 가비지 컬렉션 기본 알고리즘
 - 가비지 컬렉터는 루트(root) 정보 수집, ‘mark(기억)’ 함
 - 루트가 참조하고 있는 모든 객체를 방문, 이것들을 ‘mark’ 함
 - mark 된 모든 객체에 방문, 그 객체들이 참조하는 객체도 mark 함
 - 한번 방문한 객체는 전부 mark 하기 때문에 같은 객체를 다시 방문하는 일은 없음
 - 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복
 - mark 되지 않은 모든 객체를 메모리에서 삭제합니다.

최적화 기법
 - generational collection(세대별 수집)
   : 객체를 '새로운 객체’와 '오래된 객체’로 나눔
     객체 상당수는 생성 이후 제 역할을 빠르게 수행해 금방 쓸모가 없어지는데, 이런 객체를 '새로운 객체’로 구분
     가비지 컬렉터는 이런 객체를 공격적으로 메모리에서 제거
     일정 시간 이상 동안 살아남은 객체는 '오래된 객체’로 분류, 가비지 컬렉터가 덜 감시합니다.

 - incremental collection(점진적 수집)
   : 방문해야 할 객체가 많다면 모든 객체를 한 번에 방문하고 mark 하는데 상당한 시간이 소모
     가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 눈에 띄게 느려짐
     자바스크립트 엔진은 이런 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행
     작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점

 - idle-time collection(유휴 시간 수집)
   : 가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행




## 매서드와 this

객체 = 사용자(user), 주문(order)등 실제 존재하는 개체(entity)를 표현하고자 할 때 생성
  let user = {
    name: "hamburger",
    age: 30
  };
 - 사용자를 나타내는 객체(user)에도 특정 행동 가능

매서드 만들기 (이해가 갈동말동!)
 - 객체 프로퍼티에 할당된 함수를 매서드라고 함!!!!!!

매서드 단축 구문
 - 객체 리터럴 안에 매서드를 선언할 때 사용
   user = {sayHi: function(){alert("Hello");}};
   user = {sayHi(){alert("Hello");}};
   - 2번째가 단축한 구문

매서드와 this
 - 매서드는 객체에 저장된 정보에 접근할 수 있어야함!! 그래야 역할을 수행
 - 대부분의 매서드가 객체 프로퍼티 값 활용
 - 매서드 내부에서 this 키워드를 사용하면 객체의 접근할 수 잇음
   let user = {
    name: "John",
    age: 30,

    sayHi() {
      alert(this.name);
    }
   };
user.sayHi(); // John

 - 점 앞의 this는 객체를 나타냄(=매서드를 호출할 때 사용된 객체)
   (this.name) "this"는 "현재 객체"를 나타냄
 - this를 사용하지 않고 외부 변수를 참조해 객체 접근 가능!
 - 그러나 외부 변수를 사용해 객체를 참조하면 에러 발생가능성도 있음
 - user를 복사해 다른 변수에 할당하고 값은 다른값을 매겼을 때, sayHi()는 null(원치 않는 값)을 참조

자유로운 this
 - 자바스크립트에서는 모든 함수에 this를 사용가능 (아니 이럴수가?!)
 - 동일한 함수라도 다른객체에서 호출했다면 this가 참조하는 값은 다름

this가 없는 화살표 함수
 - 화살표함수는 일반함수와 다르게 "고유한" this를 가지지 않음
 - 화살표함수에서 this를 참조하면, 화살표함수가 아닌 "평범한" 외부함수에서 this값을 가져옴
 - 별개의 this가 만들어지는건 원하지 않고, 외부 컨텍스트에 있는 this를 이용하고 싶을 때는 화살표함수가 유용




## new 연산자와 생성자 함수

객체 리터럴({...})을 사용하면 객체를 쉽게 만들 수 있음.
그러나 유사한 객체를 여러개 만들어야 할 때가 생김
"new" 연산자와 생성자 함수를 사용하면 유사 객체 여러개를 쉽게 만들 수 있음

생성자 함수
 - 일반함수에 기술적인 차이는 없음
 - 두개의 관례를 따름
   : 함수의 이름의 첫글자는 대문자로 시작
     반드시 "new" 연산자를 붙여 실행
 - 모든 함수는 생성자 함수가 될 수 있음
 - new를 붙여 실행한다면 어떤 함수라도 위에 언급된 알고리즘이 실행
 - 이름의 '첫 글자가 대문자’인 함수는 new를 붙여 실행해야 한다는 점 (공동의 약속)

new.target과 생성자 함수
 - 자주 쓰이지 않음! 가볍게 읽고만 넘어가자! 나중에 등장하면 그때 보는걸로!

생성자와 return문
 - 생성자 함수에는 return 문이 없음
 - 반환해야 할 것들은 모두 this에 저장
 - this는 자동으로 반환되기 때문에 반환문을 명시적으로 써 줄 필요가 없음
 - 만약 return문이 있다면,
   객체를 return 한다면 this 대신 객체가 반환
   원시형을 return 한다면 return문이 무시
 - 괄호 생략하기
   인수가 없는 생성자 함수는 괄호를 생략해 호출할 수 있음
   let user = new User; // <-- 괄호가 없음
   // 아래 코드는 위 코드와 똑같이 동작합니다.
   let user = new User();
   생략해도 되지만 좋은 스타일은 아님!

생성자 내 메서드
 - 생성자 함수를 사용하면 매개변수를 이용해 객체 내부를 자유롭게 구성 가능 (엄청난 유연성 확보)
 - this에 프로퍼티를 더해주는 것도 있지만 / 메서드를 더해주는 것도 가능




## 옵셔널 체이닝 "?."

옵셔널 체이닝을 사용하면 프로퍼티가 없는 중첩 객체를 에러없이 안전하게 접근 가능

옵셔널 체이닝이 필요한 이유
 - 사용자가 여러명 있는데 그 중 몇명은 주소 정보가 없음 -> 이때 user.address.street를 사용해 정보에 접근 -> 에러 발생
  let user = {}; // 주소 정보가 없는 사용자
  alert(user.address.street); // TypeError: Cannot read property 'street' of undefined
 - ?.가 추가되기 전에는 &&연산자를 사용함

옵셔널 체이닝의 등장
 - ?.은 ?.'앞’의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환
 - ?. 앞의 객체가 존재하지 않더라도 에러가 발생하지 않는다 / 앞 평가 대상에만 동작되는게 신기..

옵셔널 체이닝 주의사항
 - ?.는 존재하지 않아도 괜찮은 대상에게만 사용해야함 (반드시)
 - ?. 앞의 변수는 꼭 선언되어 있어야 함

단락 평가
 - ?.는 왼쪽 평가대상에 값이 없으면 즉시 평가를 멈춤 = 단락평가
 - 함수 호출을 비롯한 ?. 오른쪽에 있는 부가 동작은 ?.의 평가가 멈췄을 때 더는 일어나지 않는다.

?.()와 ?.[]
 - ?.는 함수나 대괄호와 함께 동작하는 특별한 문법 구조체
 - 두 상황 모두에서 user 객체는 존재하기 때문에 admin 프로퍼티는 .만 사용해 접근했습니다.
 - 대신 대괄호 []를 사용해 객체 프로퍼티에 접근하는 경우엔 ?.[]를 사용할 수도 있습니다. 위 예시와 마찬가지로 ?.[]를 사용하면 객체 존재 여부가 확실치 않은 경우에도 안전하게 프로퍼티를 읽을 수 있음

delete와 조합
 - delete aaa?.color;




## 심볼형

자바스크립트는 객체 프로퍼티 키로 오직 문자형과 심볼형만을 허용
숫자형, 불린형 모두 불가능

심볼
 - 유일한 식별자를 만들고 싶을 때 사용
 - let id = Symbol();  //id는 새로운 심볼

심볼은 문자형으로 자동 형 변환되지 않음
 - 자바스크립트에서는 문자형으로의 암시적 형 변환이 자유로운편 (alert 함수가 거의 모든 값을 인자로 받을 수 있는 이유, 심볼은 예외)
 - 문자열과 심볼은 근본이 다름 -> 우연히라도 서로의 타입으로 변환해서는 안됨

"숨김" 프로퍼티
 - 심볼을 이용하면 숨김 프로퍼티를 만들 수 있음
 - 숨김 프로퍼티는 외부 코드에서 접근 불가능
 - 값도 덮어쓸 수 없는 프로퍼티

 - 심볼은 유일성이 보장 -> 우리가 만든 식별자와 제 3의 스크립트에서 만든 식별자가 이름이 같더라도 충돌하지 않음
 - 심볼 대신 문자열 "id"를 사용해 식별자를 만들었다면 충돌 발생 가능성 있음

Symbols in a literal
  let id = Symbol("id");

  let user = {
    name: "John",
    [id]: 123                  // "id": 123은 안됨, id:123이라면 심볼 id가 아니고 문자열 "id"키가 됨
  };

심볼은 for...in에서 배제됨
 - 키가 심볼인 프로퍼티는 for...in 반복문에서 배제
 - Object.assign : 키가 심볼인 프로퍼티를 배제하지 않고 객체 내 모든 프로퍼티를 복사하느거네요..

전역 심볼
 - 심볼은 이름이 같더라도 모두 별개 취급
 - 이름이 같은 심볼이 같은 개체를 가리키길 원하는 경우도 있음
 
 - 전역 심볼 레지스트리는 이런 경우를 위해 만들어짐
 - 전역 심볼 레지스트리 안에 심볼을 만들고 해당 심볼에 접근
 - 이름이 같은 경우 항상 동일한 심볼을 반환

 - 전역 심볼 레지스트리 안에 있는 심볼은 전역 심볼이라고 불림

Symbol.keyFor
 - 전역 심볼을 찾을 때 사용되는 Symbol.for(key)에 반대되는 메서드도 있음
 - Symbol.keyFor(sym)을 사용하면 이름을 얻을 수 있음
 - Symbol.keyFor는 전역 심볼 레지스트리를 뒤져서 해당 심볼 이름 얻어낸다.
 - 검색 범위가 전역 심볼 레지스트리이기 때문에 전역심볼이 아닌 심볼에는 사용할 수 없음
 - 전역심볼이 아닌 인자가 넘어오면 Symbol.keyFor는 undefined

시스템 심볼
시스템 심볼은 자바스크립트 내부에서 사용되는 심볼
 - 객체를 미세 조정할 수 있음
 - 명세서 내의 표, 잘 알려진 심볼 목록
   Symbol.hasInstance
   Symbol.isConcatSpreadable
   Symbol.iterator
   Symbol.toPrimitive




## 객체를 원시형으로 변환하기

 - obj1 + obj2 처럼 객체끼리 더하는 연산을 하거나,
   obj1 - obj2 처름 객체끼리 빼는 연산을 하면
   모든 경우에 자동형 변환이 일어남 (객체는 원시값으로 변환되고, 의도한 연산이 수행)
 - 객체는 논리 평가 시 true 반환(예외 없음) 따라서 객체는 숫자형이나 문자형으로만 형변환이 일어남
 - 숫자형의 형 변환은 객체끼리 빼는 연산을 할 때나 수학 관련 함수를 적용할 때 일어남
   Date끼리 차감 (date1 - date2) 두 날짜의 시간 차이가 반환
 - 문자형의 형 변환은 대체로 alert(obj) 같이 객체를 출력하려고 할때 필요

ToPrimitive
 - 특수 객체 메서드를 사용하면 숫자형이나 문자형으로 형 변환을 원하는대로 조절할 수 있음
 - 객체 형 변환은 세종류로 구분 (hint라 불리는 값이 구분 기준이 됨 : 목표로 하는 자료형)
   - "string"
     : alert 함수같이 문자열을 기대하는 연산을 수행할 때는(객체-문자형 변환), hint가 string이 됨
   - "number"
     : 수학 연산을 적용하려 할 때(객체-숫자형 변환), hint는 number가 됨
   - "default"
     : 연산자가 기대하는 자료형이 ‘확실치 않을 때’ hint는 default가 됩니다. 아주 드물게 발생

       - 이항 덧셈 연산자 +는 피연산자의 자료형에 따라 문자열을 합치는 연산 또는 숫자를 더해주는 연산을 함
         따라서 +의 인수가 hint가 default가 됨
       - 동등 연산자 ==를 사용해 객체-문자형, 객체-심볼형끼리 비교할 때도,
         객체를 어떤 자료형으로 바꿔야 할지 확신이 안서므로
         hint는 default가 됨
       - 크고 작음을 비교할 때 쓰이는 연산자 <, > 피연산자에 문자형과 숫자형 둘 다 허용
         hint는 number로 고정
 - 객체에 obj[Symbol.toPrimitive](hint)메서드가 있는지 찾고, 있다면 메서드를 호출 (Symbol.toPrimitive는 시스템 심볼로, 심볼형 키)
   obj.toString()이나 obj.valueOf()를 호출(존재하는 메서드만 실행됨)
   1과 2에 해당하지 않고, hint가 "number"나 "default"라면
   obj.valueOf()나 obj.toString()을 호출(존재하는 메서드만 실행됨)

Symbol.toPrimitive
 - Symbol.toPrimitive 라는 내장 심볼이 존재

toString과 valueOf
 - toString과 valueOf는 심볼이 생기기 이전부터 존재해 왔던 ‘평범한’ 메서드
 - 메서드를 이용하면 '구식’이긴 하지만 형 변환을 직접 구현할 수 있음
 - 객체에 Symbol.toPrimitive가 없으면 자바스크립트는 규칙에 따라 toString이나 valueOf를 호출합니다.
 - 그 외: valueOf -> toString 순

 - 이 메서드들은 반드시 원시값을 반환해야합니다. toString이나 valueOf가 객체를 반환하면 그 결과는 무시됩니다. 마치 메서드가 처음부터 없었던 것처럼 됨
 - 일반 객체는 기본적으로 toString과 valueOf에 적용되는 다음 규칙을 따른다.
 - toString은 문자열 "[object Object]"을 반환
 - valueOf는 객체 자신을 반환

반환 타입
 - "string", "number", "default"의 세가지 메서드는 hint에 명시된 자료형으로 형 변환을 보장해 주지 않습니다.
 -Symbol.toPrimitive는 무조건 원시자료를 반환해야 합니다. 그렇지 않으면 에러가 발생합니다.

추가 형 변환
 - 상당수의 연산자와 함수가 피연산자의 형을 변환
 - 곱셈을 해주는 연산자 *는 피연산자를 숫자형으로 변환시킴
 - 객체는 원시형으로 변화 -> 변환 후 원시값이 원하는형이 아닌 경우 다시 형 반환 일어남
